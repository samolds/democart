// AUTOGENERATED BY gopkg.in/spacemonkeygo/dbx.v1
// DO NOT EDIT.

package database

import (
	"bytes"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode"

	"github.com/lib/pq"

	"github.com/mattn/go-sqlite3"
	"math/rand"
)

// Prevent conditional imports from causing build failures
var _ = strconv.Itoa
var _ = strings.LastIndex
var _ = fmt.Sprint
var _ sync.Mutex

var (
	WrapErr = func(err *Error) error { return err }
	Logger  func(format string, args ...interface{})

	errTooManyRows       = errors.New("too many rows")
	errUnsupportedDriver = errors.New("unsupported driver")
	errEmptyUpdate       = errors.New("empty update")
)

func logError(format string, args ...interface{}) {
	if Logger != nil {
		Logger(format, args...)
	}
}

type ErrorCode int

const (
	ErrorCode_Unknown ErrorCode = iota
	ErrorCode_UnsupportedDriver
	ErrorCode_NoRows
	ErrorCode_TxDone
	ErrorCode_TooManyRows
	ErrorCode_ConstraintViolation
	ErrorCode_EmptyUpdate
)

type Error struct {
	Err         error
	Code        ErrorCode
	Driver      string
	Constraint  string
	QuerySuffix string
}

func (e *Error) Error() string {
	return e.Err.Error()
}

func wrapErr(e *Error) error {
	if WrapErr == nil {
		return e
	}
	return WrapErr(e)
}

func makeErr(err error) error {
	if err == nil {
		return nil
	}
	e := &Error{Err: err}
	switch err {
	case sql.ErrNoRows:
		e.Code = ErrorCode_NoRows
	case sql.ErrTxDone:
		e.Code = ErrorCode_TxDone
	}
	return wrapErr(e)
}

func unsupportedDriver(driver string) error {
	return wrapErr(&Error{
		Err:    errUnsupportedDriver,
		Code:   ErrorCode_UnsupportedDriver,
		Driver: driver,
	})
}

func emptyUpdate() error {
	return wrapErr(&Error{
		Err:  errEmptyUpdate,
		Code: ErrorCode_EmptyUpdate,
	})
}

func tooManyRows(query_suffix string) error {
	return wrapErr(&Error{
		Err:         errTooManyRows,
		Code:        ErrorCode_TooManyRows,
		QuerySuffix: query_suffix,
	})
}

func constraintViolation(err error, constraint string) error {
	return wrapErr(&Error{
		Err:        err,
		Code:       ErrorCode_ConstraintViolation,
		Constraint: constraint,
	})
}

type driver interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
}

var (
	notAPointer     = errors.New("destination not a pointer")
	lossyConversion = errors.New("lossy conversion")
)

type DB struct {
	*sql.DB
	dbMethods

	Hooks struct {
		Now func() time.Time
	}
}

func Open(driver, source string) (db *DB, err error) {
	var sql_db *sql.DB
	switch driver {
	case "postgres":
		sql_db, err = openpostgres(source)
	case "sqlite3":
		sql_db, err = opensqlite3(source)
	default:
		return nil, unsupportedDriver(driver)
	}
	if err != nil {
		return nil, makeErr(err)
	}
	defer func(sql_db *sql.DB) {
		if err != nil {
			sql_db.Close()
		}
	}(sql_db)

	if err := sql_db.Ping(); err != nil {
		return nil, makeErr(err)
	}

	db = &DB{
		DB: sql_db,
	}
	db.Hooks.Now = time.Now

	switch driver {
	case "postgres":
		db.dbMethods = newpostgres(db)
	case "sqlite3":
		db.dbMethods = newsqlite3(db)
	default:
		return nil, unsupportedDriver(driver)
	}

	return db, nil
}

func (obj *DB) Close() (err error) {
	return obj.makeErr(obj.DB.Close())
}

func (obj *DB) Open(ctx context.Context) (*Tx, error) {
	tx, err := obj.DB.Begin()
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return &Tx{
		Tx:        tx,
		txMethods: obj.wrapTx(tx),
	}, nil
}

func (obj *DB) NewRx() *Rx {
	return &Rx{db: obj}
}

func DeleteAll(ctx context.Context, db *DB) (int64, error) {
	tx, err := db.Open(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err == nil {
			err = db.makeErr(tx.Commit())
			return
		}

		if err_rollback := tx.Rollback(); err_rollback != nil {
			logError("delete-all: rollback failed: %v", db.makeErr(err_rollback))
		}
	}()
	return tx.deleteAll(ctx)
}

type Tx struct {
	Tx *sql.Tx
	txMethods
}

type dialectTx struct {
	tx *sql.Tx
}

func (tx *dialectTx) Commit() (err error) {
	return makeErr(tx.tx.Commit())
}

func (tx *dialectTx) Rollback() (err error) {
	return makeErr(tx.tx.Rollback())
}

type postgresImpl struct {
	db      *DB
	dialect __sqlbundle_postgres
	driver  driver
}

func (obj *postgresImpl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *postgresImpl) logStmt(stmt string, args ...interface{}) {
	postgresLogStmt(stmt, args...)
}

func (obj *postgresImpl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type postgresDB struct {
	db *DB
	*postgresImpl
}

func newpostgres(db *DB) *postgresDB {
	return &postgresDB{
		db: db,
		postgresImpl: &postgresImpl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *postgresDB) Schema() string {
	return `CREATE TABLE email_passwords (
	pk bigserial NOT NULL,
	email text NOT NULL,
	password_hash bytea NOT NULL,
	created timestamp NOT NULL,
	passowrd_updated timestamp NOT NULL,
	last_login timestamp NOT NULL,
	code text NOT NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( email )
);
CREATE TABLE users (
	pk bigserial NOT NULL,
	id text NOT NULL,
	email text NOT NULL,
	created timestamp NOT NULL,
	profile_url text NOT NULL,
	full_name text NOT NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id ),
	UNIQUE ( email )
);
CREATE TABLE addresses (
	pk bigserial NOT NULL,
	id text NOT NULL,
	created timestamp NOT NULL,
	line1 text NOT NULL,
	line2 text NOT NULL,
	line3 text NOT NULL,
	country text NOT NULL,
	state text NOT NULL,
	city text NOT NULL,
	zip text NOT NULL,
	phone text NOT NULL,
	notes text NOT NULL,
	user_pk bigint REFERENCES users( pk ) ON DELETE SET NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
);
CREATE TABLE items (
	pk bigserial NOT NULL,
	id text NOT NULL,
	created timestamp NOT NULL,
	price integer NOT NULL,
	description text NOT NULL,
	image_url text NOT NULL,
	remaining_quantity integer NOT NULL,
	owning_user_pk bigint REFERENCES users( pk ) ON DELETE SET NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
);
CREATE TABLE sessions (
	pk bigserial NOT NULL,
	id text NOT NULL,
	created timestamp NOT NULL,
	id_token text NOT NULL,
	access_token text NOT NULL,
	refresh_token text NOT NULL,
	access_token_expiry timestamp NOT NULL,
	device_name text NOT NULL,
	user_pk bigint REFERENCES users( pk ) ON DELETE CASCADE,
	PRIMARY KEY ( pk ),
	UNIQUE ( id ),
	UNIQUE ( id_token ),
	UNIQUE ( access_token ),
	UNIQUE ( refresh_token )
);
CREATE TABLE cart_items (
	pk bigserial NOT NULL,
	id text NOT NULL,
	created timestamp NOT NULL,
	quantity integer NOT NULL,
	user_pk bigint REFERENCES users( pk ) ON DELETE SET NULL,
	item_pk bigint REFERENCES items( pk ) ON DELETE SET NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id ),
	UNIQUE ( user_pk, item_pk )
);
CREATE TABLE ordered_items (
	pk bigserial NOT NULL,
	id text NOT NULL,
	created timestamp NOT NULL,
	quantity integer NOT NULL,
	delivered boolean NOT NULL,
	price integer NOT NULL,
	user_pk bigint REFERENCES users( pk ) ON DELETE SET NULL,
	item_pk bigint NOT NULL REFERENCES items( pk ),
	address_pk bigint NOT NULL REFERENCES addresses( pk ),
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
);`
}

func (obj *postgresDB) wrapTx(tx *sql.Tx) txMethods {
	return &postgresTx{
		dialectTx: dialectTx{tx: tx},
		postgresImpl: &postgresImpl{
			db:     obj.db,
			driver: tx,
		},
	}
}

type postgresTx struct {
	dialectTx
	*postgresImpl
}

func postgresLogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type sqlite3Impl struct {
	db      *DB
	dialect __sqlbundle_sqlite3
	driver  driver
}

func (obj *sqlite3Impl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *sqlite3Impl) logStmt(stmt string, args ...interface{}) {
	sqlite3LogStmt(stmt, args...)
}

func (obj *sqlite3Impl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type sqlite3DB struct {
	db *DB
	*sqlite3Impl
}

func newsqlite3(db *DB) *sqlite3DB {
	return &sqlite3DB{
		db: db,
		sqlite3Impl: &sqlite3Impl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *sqlite3DB) Schema() string {
	return `CREATE TABLE email_passwords (
	pk INTEGER NOT NULL,
	email TEXT NOT NULL,
	password_hash BLOB NOT NULL,
	created TIMESTAMP NOT NULL,
	passowrd_updated TIMESTAMP NOT NULL,
	last_login TIMESTAMP NOT NULL,
	code TEXT NOT NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( email )
);
CREATE TABLE users (
	pk INTEGER NOT NULL,
	id TEXT NOT NULL,
	email TEXT NOT NULL,
	created TIMESTAMP NOT NULL,
	profile_url TEXT NOT NULL,
	full_name TEXT NOT NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id ),
	UNIQUE ( email )
);
CREATE TABLE addresses (
	pk INTEGER NOT NULL,
	id TEXT NOT NULL,
	created TIMESTAMP NOT NULL,
	line1 TEXT NOT NULL,
	line2 TEXT NOT NULL,
	line3 TEXT NOT NULL,
	country TEXT NOT NULL,
	state TEXT NOT NULL,
	city TEXT NOT NULL,
	zip TEXT NOT NULL,
	phone TEXT NOT NULL,
	notes TEXT NOT NULL,
	user_pk INTEGER REFERENCES users( pk ) ON DELETE SET NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
);
CREATE TABLE items (
	pk INTEGER NOT NULL,
	id TEXT NOT NULL,
	created TIMESTAMP NOT NULL,
	price INTEGER NOT NULL,
	description TEXT NOT NULL,
	image_url TEXT NOT NULL,
	remaining_quantity INTEGER NOT NULL,
	owning_user_pk INTEGER REFERENCES users( pk ) ON DELETE SET NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
);
CREATE TABLE sessions (
	pk INTEGER NOT NULL,
	id TEXT NOT NULL,
	created TIMESTAMP NOT NULL,
	id_token TEXT NOT NULL,
	access_token TEXT NOT NULL,
	refresh_token TEXT NOT NULL,
	access_token_expiry TIMESTAMP NOT NULL,
	device_name TEXT NOT NULL,
	user_pk INTEGER REFERENCES users( pk ) ON DELETE CASCADE,
	PRIMARY KEY ( pk ),
	UNIQUE ( id ),
	UNIQUE ( id_token ),
	UNIQUE ( access_token ),
	UNIQUE ( refresh_token )
);
CREATE TABLE cart_items (
	pk INTEGER NOT NULL,
	id TEXT NOT NULL,
	created TIMESTAMP NOT NULL,
	quantity INTEGER NOT NULL,
	user_pk INTEGER REFERENCES users( pk ) ON DELETE SET NULL,
	item_pk INTEGER REFERENCES items( pk ) ON DELETE SET NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id ),
	UNIQUE ( user_pk, item_pk )
);
CREATE TABLE ordered_items (
	pk INTEGER NOT NULL,
	id TEXT NOT NULL,
	created TIMESTAMP NOT NULL,
	quantity INTEGER NOT NULL,
	delivered INTEGER NOT NULL,
	price INTEGER NOT NULL,
	user_pk INTEGER REFERENCES users( pk ) ON DELETE SET NULL,
	item_pk INTEGER NOT NULL REFERENCES items( pk ),
	address_pk INTEGER NOT NULL REFERENCES addresses( pk ),
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
);`
}

func (obj *sqlite3DB) wrapTx(tx *sql.Tx) txMethods {
	return &sqlite3Tx{
		dialectTx: dialectTx{tx: tx},
		sqlite3Impl: &sqlite3Impl{
			db:     obj.db,
			driver: tx,
		},
	}
}

type sqlite3Tx struct {
	dialectTx
	*sqlite3Impl
}

func sqlite3LogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type pretty []interface{}

func (p pretty) Format(f fmt.State, c rune) {
	fmt.Fprint(f, "[")
nextval:
	for i, val := range p {
		if i > 0 {
			fmt.Fprint(f, ", ")
		}
		rv := reflect.ValueOf(val)
		if rv.Kind() == reflect.Ptr {
			if rv.IsNil() {
				fmt.Fprint(f, "NULL")
				continue
			}
			val = rv.Elem().Interface()
		}
		switch v := val.(type) {
		case string:
			fmt.Fprintf(f, "%q", v)
		case time.Time:
			fmt.Fprintf(f, "%s", v.Format(time.RFC3339Nano))
		case []byte:
			for _, b := range v {
				if !unicode.IsPrint(rune(b)) {
					fmt.Fprintf(f, "%#x", v)
					continue nextval
				}
			}
			fmt.Fprintf(f, "%q", v)
		default:
			fmt.Fprintf(f, "%v", v)
		}
	}
	fmt.Fprint(f, "]")
}

type EmailPassword struct {
	Pk              int64
	Email           string
	PasswordHash    []byte
	Created         time.Time
	PassowrdUpdated time.Time
	LastLogin       time.Time
	Code            string
}

func (EmailPassword) _Table() string { return "email_passwords" }

type EmailPassword_Update_Fields struct {
	Email           EmailPassword_Email_Field
	PasswordHash    EmailPassword_PasswordHash_Field
	PassowrdUpdated EmailPassword_PassowrdUpdated_Field
	Code            EmailPassword_Code_Field
}

type EmailPassword_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func EmailPassword_Pk(v int64) EmailPassword_Pk_Field {
	return EmailPassword_Pk_Field{_set: true, _value: v}
}

func (f EmailPassword_Pk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (EmailPassword_Pk_Field) _Column() string { return "pk" }

type EmailPassword_Email_Field struct {
	_set   bool
	_null  bool
	_value string
}

func EmailPassword_Email(v string) EmailPassword_Email_Field {
	return EmailPassword_Email_Field{_set: true, _value: v}
}

func (f EmailPassword_Email_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (EmailPassword_Email_Field) _Column() string { return "email" }

type EmailPassword_PasswordHash_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func EmailPassword_PasswordHash(v []byte) EmailPassword_PasswordHash_Field {
	return EmailPassword_PasswordHash_Field{_set: true, _value: v}
}

func (f EmailPassword_PasswordHash_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (EmailPassword_PasswordHash_Field) _Column() string { return "password_hash" }

type EmailPassword_Created_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func EmailPassword_Created(v time.Time) EmailPassword_Created_Field {
	v = toUTC(v)
	return EmailPassword_Created_Field{_set: true, _value: v}
}

func (f EmailPassword_Created_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (EmailPassword_Created_Field) _Column() string { return "created" }

type EmailPassword_PassowrdUpdated_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func EmailPassword_PassowrdUpdated(v time.Time) EmailPassword_PassowrdUpdated_Field {
	v = toUTC(v)
	return EmailPassword_PassowrdUpdated_Field{_set: true, _value: v}
}

func (f EmailPassword_PassowrdUpdated_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (EmailPassword_PassowrdUpdated_Field) _Column() string { return "passowrd_updated" }

type EmailPassword_LastLogin_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func EmailPassword_LastLogin(v time.Time) EmailPassword_LastLogin_Field {
	v = toUTC(v)
	return EmailPassword_LastLogin_Field{_set: true, _value: v}
}

func (f EmailPassword_LastLogin_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (EmailPassword_LastLogin_Field) _Column() string { return "last_login" }

type EmailPassword_Code_Field struct {
	_set   bool
	_null  bool
	_value string
}

func EmailPassword_Code(v string) EmailPassword_Code_Field {
	return EmailPassword_Code_Field{_set: true, _value: v}
}

func (f EmailPassword_Code_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (EmailPassword_Code_Field) _Column() string { return "code" }

type User struct {
	Pk         int64
	Id         string
	Email      string
	Created    time.Time
	ProfileUrl string
	FullName   string
}

func (User) _Table() string { return "users" }

type User_Update_Fields struct {
	Email User_Email_Field
}

type User_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func User_Pk(v int64) User_Pk_Field {
	return User_Pk_Field{_set: true, _value: v}
}

func (f User_Pk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_Pk_Field) _Column() string { return "pk" }

type User_Id_Field struct {
	_set   bool
	_null  bool
	_value string
}

func User_Id(v string) User_Id_Field {
	return User_Id_Field{_set: true, _value: v}
}

func (f User_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_Id_Field) _Column() string { return "id" }

type User_Email_Field struct {
	_set   bool
	_null  bool
	_value string
}

func User_Email(v string) User_Email_Field {
	return User_Email_Field{_set: true, _value: v}
}

func (f User_Email_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_Email_Field) _Column() string { return "email" }

type User_Created_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func User_Created(v time.Time) User_Created_Field {
	v = toUTC(v)
	return User_Created_Field{_set: true, _value: v}
}

func (f User_Created_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_Created_Field) _Column() string { return "created" }

type User_ProfileUrl_Field struct {
	_set   bool
	_null  bool
	_value string
}

func User_ProfileUrl(v string) User_ProfileUrl_Field {
	return User_ProfileUrl_Field{_set: true, _value: v}
}

func (f User_ProfileUrl_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_ProfileUrl_Field) _Column() string { return "profile_url" }

type User_FullName_Field struct {
	_set   bool
	_null  bool
	_value string
}

func User_FullName(v string) User_FullName_Field {
	return User_FullName_Field{_set: true, _value: v}
}

func (f User_FullName_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_FullName_Field) _Column() string { return "full_name" }

type Address struct {
	Pk      int64
	Id      string
	Created time.Time
	Line1   string
	Line2   string
	Line3   string
	Country string
	State   string
	City    string
	Zip     string
	Phone   string
	Notes   string
	UserPk  *int64
}

func (Address) _Table() string { return "addresses" }

type Address_Create_Fields struct {
	UserPk Address_UserPk_Field
}

type Address_Update_Fields struct {
}

type Address_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Address_Pk(v int64) Address_Pk_Field {
	return Address_Pk_Field{_set: true, _value: v}
}

func (f Address_Pk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Address_Pk_Field) _Column() string { return "pk" }

type Address_Id_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Address_Id(v string) Address_Id_Field {
	return Address_Id_Field{_set: true, _value: v}
}

func (f Address_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Address_Id_Field) _Column() string { return "id" }

type Address_Created_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Address_Created(v time.Time) Address_Created_Field {
	v = toUTC(v)
	return Address_Created_Field{_set: true, _value: v}
}

func (f Address_Created_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Address_Created_Field) _Column() string { return "created" }

type Address_Line1_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Address_Line1(v string) Address_Line1_Field {
	return Address_Line1_Field{_set: true, _value: v}
}

func (f Address_Line1_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Address_Line1_Field) _Column() string { return "line1" }

type Address_Line2_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Address_Line2(v string) Address_Line2_Field {
	return Address_Line2_Field{_set: true, _value: v}
}

func (f Address_Line2_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Address_Line2_Field) _Column() string { return "line2" }

type Address_Line3_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Address_Line3(v string) Address_Line3_Field {
	return Address_Line3_Field{_set: true, _value: v}
}

func (f Address_Line3_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Address_Line3_Field) _Column() string { return "line3" }

type Address_Country_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Address_Country(v string) Address_Country_Field {
	return Address_Country_Field{_set: true, _value: v}
}

func (f Address_Country_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Address_Country_Field) _Column() string { return "country" }

type Address_State_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Address_State(v string) Address_State_Field {
	return Address_State_Field{_set: true, _value: v}
}

func (f Address_State_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Address_State_Field) _Column() string { return "state" }

type Address_City_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Address_City(v string) Address_City_Field {
	return Address_City_Field{_set: true, _value: v}
}

func (f Address_City_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Address_City_Field) _Column() string { return "city" }

type Address_Zip_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Address_Zip(v string) Address_Zip_Field {
	return Address_Zip_Field{_set: true, _value: v}
}

func (f Address_Zip_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Address_Zip_Field) _Column() string { return "zip" }

type Address_Phone_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Address_Phone(v string) Address_Phone_Field {
	return Address_Phone_Field{_set: true, _value: v}
}

func (f Address_Phone_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Address_Phone_Field) _Column() string { return "phone" }

type Address_Notes_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Address_Notes(v string) Address_Notes_Field {
	return Address_Notes_Field{_set: true, _value: v}
}

func (f Address_Notes_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Address_Notes_Field) _Column() string { return "notes" }

type Address_UserPk_Field struct {
	_set   bool
	_null  bool
	_value *int64
}

func Address_UserPk(v int64) Address_UserPk_Field {
	return Address_UserPk_Field{_set: true, _value: &v}
}

func Address_UserPk_Raw(v *int64) Address_UserPk_Field {
	if v == nil {
		return Address_UserPk_Null()
	}
	return Address_UserPk(*v)
}

func Address_UserPk_Null() Address_UserPk_Field {
	return Address_UserPk_Field{_set: true, _null: true}
}

func (f Address_UserPk_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Address_UserPk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Address_UserPk_Field) _Column() string { return "user_pk" }

type Item struct {
	Pk                int64
	Id                string
	Created           time.Time
	Price             int
	Description       string
	ImageUrl          string
	RemainingQuantity int
	OwningUserPk      *int64
}

func (Item) _Table() string { return "items" }

type Item_Create_Fields struct {
	OwningUserPk Item_OwningUserPk_Field
}

type Item_Update_Fields struct {
	Price             Item_Price_Field
	Description       Item_Description_Field
	ImageUrl          Item_ImageUrl_Field
	RemainingQuantity Item_RemainingQuantity_Field
}

type Item_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Item_Pk(v int64) Item_Pk_Field {
	return Item_Pk_Field{_set: true, _value: v}
}

func (f Item_Pk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Item_Pk_Field) _Column() string { return "pk" }

type Item_Id_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Item_Id(v string) Item_Id_Field {
	return Item_Id_Field{_set: true, _value: v}
}

func (f Item_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Item_Id_Field) _Column() string { return "id" }

type Item_Created_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Item_Created(v time.Time) Item_Created_Field {
	v = toUTC(v)
	return Item_Created_Field{_set: true, _value: v}
}

func (f Item_Created_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Item_Created_Field) _Column() string { return "created" }

type Item_Price_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Item_Price(v int) Item_Price_Field {
	return Item_Price_Field{_set: true, _value: v}
}

func (f Item_Price_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Item_Price_Field) _Column() string { return "price" }

type Item_Description_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Item_Description(v string) Item_Description_Field {
	return Item_Description_Field{_set: true, _value: v}
}

func (f Item_Description_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Item_Description_Field) _Column() string { return "description" }

type Item_ImageUrl_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Item_ImageUrl(v string) Item_ImageUrl_Field {
	return Item_ImageUrl_Field{_set: true, _value: v}
}

func (f Item_ImageUrl_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Item_ImageUrl_Field) _Column() string { return "image_url" }

type Item_RemainingQuantity_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Item_RemainingQuantity(v int) Item_RemainingQuantity_Field {
	return Item_RemainingQuantity_Field{_set: true, _value: v}
}

func (f Item_RemainingQuantity_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Item_RemainingQuantity_Field) _Column() string { return "remaining_quantity" }

type Item_OwningUserPk_Field struct {
	_set   bool
	_null  bool
	_value *int64
}

func Item_OwningUserPk(v int64) Item_OwningUserPk_Field {
	return Item_OwningUserPk_Field{_set: true, _value: &v}
}

func Item_OwningUserPk_Raw(v *int64) Item_OwningUserPk_Field {
	if v == nil {
		return Item_OwningUserPk_Null()
	}
	return Item_OwningUserPk(*v)
}

func Item_OwningUserPk_Null() Item_OwningUserPk_Field {
	return Item_OwningUserPk_Field{_set: true, _null: true}
}

func (f Item_OwningUserPk_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Item_OwningUserPk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Item_OwningUserPk_Field) _Column() string { return "owning_user_pk" }

type Session struct {
	Pk                int64
	Id                string
	Created           time.Time
	IdToken           string
	AccessToken       string
	RefreshToken      string
	AccessTokenExpiry time.Time
	DeviceName        string
	UserPk            *int64
}

func (Session) _Table() string { return "sessions" }

type Session_Create_Fields struct {
	UserPk Session_UserPk_Field
}

type Session_Update_Fields struct {
}

type Session_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Session_Pk(v int64) Session_Pk_Field {
	return Session_Pk_Field{_set: true, _value: v}
}

func (f Session_Pk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Session_Pk_Field) _Column() string { return "pk" }

type Session_Id_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Session_Id(v string) Session_Id_Field {
	return Session_Id_Field{_set: true, _value: v}
}

func (f Session_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Session_Id_Field) _Column() string { return "id" }

type Session_Created_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Session_Created(v time.Time) Session_Created_Field {
	v = toUTC(v)
	return Session_Created_Field{_set: true, _value: v}
}

func (f Session_Created_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Session_Created_Field) _Column() string { return "created" }

type Session_IdToken_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Session_IdToken(v string) Session_IdToken_Field {
	return Session_IdToken_Field{_set: true, _value: v}
}

func (f Session_IdToken_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Session_IdToken_Field) _Column() string { return "id_token" }

type Session_AccessToken_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Session_AccessToken(v string) Session_AccessToken_Field {
	return Session_AccessToken_Field{_set: true, _value: v}
}

func (f Session_AccessToken_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Session_AccessToken_Field) _Column() string { return "access_token" }

type Session_RefreshToken_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Session_RefreshToken(v string) Session_RefreshToken_Field {
	return Session_RefreshToken_Field{_set: true, _value: v}
}

func (f Session_RefreshToken_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Session_RefreshToken_Field) _Column() string { return "refresh_token" }

type Session_AccessTokenExpiry_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Session_AccessTokenExpiry(v time.Time) Session_AccessTokenExpiry_Field {
	v = toUTC(v)
	return Session_AccessTokenExpiry_Field{_set: true, _value: v}
}

func (f Session_AccessTokenExpiry_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Session_AccessTokenExpiry_Field) _Column() string { return "access_token_expiry" }

type Session_DeviceName_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Session_DeviceName(v string) Session_DeviceName_Field {
	return Session_DeviceName_Field{_set: true, _value: v}
}

func (f Session_DeviceName_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Session_DeviceName_Field) _Column() string { return "device_name" }

type Session_UserPk_Field struct {
	_set   bool
	_null  bool
	_value *int64
}

func Session_UserPk(v int64) Session_UserPk_Field {
	return Session_UserPk_Field{_set: true, _value: &v}
}

func Session_UserPk_Raw(v *int64) Session_UserPk_Field {
	if v == nil {
		return Session_UserPk_Null()
	}
	return Session_UserPk(*v)
}

func Session_UserPk_Null() Session_UserPk_Field {
	return Session_UserPk_Field{_set: true, _null: true}
}

func (f Session_UserPk_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Session_UserPk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Session_UserPk_Field) _Column() string { return "user_pk" }

type CartItem struct {
	Pk       int64
	Id       string
	Created  time.Time
	Quantity int
	UserPk   *int64
	ItemPk   *int64
}

func (CartItem) _Table() string { return "cart_items" }

type CartItem_Create_Fields struct {
	UserPk CartItem_UserPk_Field
	ItemPk CartItem_ItemPk_Field
}

type CartItem_Update_Fields struct {
	Quantity CartItem_Quantity_Field
}

type CartItem_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func CartItem_Pk(v int64) CartItem_Pk_Field {
	return CartItem_Pk_Field{_set: true, _value: v}
}

func (f CartItem_Pk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (CartItem_Pk_Field) _Column() string { return "pk" }

type CartItem_Id_Field struct {
	_set   bool
	_null  bool
	_value string
}

func CartItem_Id(v string) CartItem_Id_Field {
	return CartItem_Id_Field{_set: true, _value: v}
}

func (f CartItem_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (CartItem_Id_Field) _Column() string { return "id" }

type CartItem_Created_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func CartItem_Created(v time.Time) CartItem_Created_Field {
	v = toUTC(v)
	return CartItem_Created_Field{_set: true, _value: v}
}

func (f CartItem_Created_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (CartItem_Created_Field) _Column() string { return "created" }

type CartItem_Quantity_Field struct {
	_set   bool
	_null  bool
	_value int
}

func CartItem_Quantity(v int) CartItem_Quantity_Field {
	return CartItem_Quantity_Field{_set: true, _value: v}
}

func (f CartItem_Quantity_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (CartItem_Quantity_Field) _Column() string { return "quantity" }

type CartItem_UserPk_Field struct {
	_set   bool
	_null  bool
	_value *int64
}

func CartItem_UserPk(v int64) CartItem_UserPk_Field {
	return CartItem_UserPk_Field{_set: true, _value: &v}
}

func CartItem_UserPk_Raw(v *int64) CartItem_UserPk_Field {
	if v == nil {
		return CartItem_UserPk_Null()
	}
	return CartItem_UserPk(*v)
}

func CartItem_UserPk_Null() CartItem_UserPk_Field {
	return CartItem_UserPk_Field{_set: true, _null: true}
}

func (f CartItem_UserPk_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f CartItem_UserPk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (CartItem_UserPk_Field) _Column() string { return "user_pk" }

type CartItem_ItemPk_Field struct {
	_set   bool
	_null  bool
	_value *int64
}

func CartItem_ItemPk(v int64) CartItem_ItemPk_Field {
	return CartItem_ItemPk_Field{_set: true, _value: &v}
}

func CartItem_ItemPk_Raw(v *int64) CartItem_ItemPk_Field {
	if v == nil {
		return CartItem_ItemPk_Null()
	}
	return CartItem_ItemPk(*v)
}

func CartItem_ItemPk_Null() CartItem_ItemPk_Field {
	return CartItem_ItemPk_Field{_set: true, _null: true}
}

func (f CartItem_ItemPk_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f CartItem_ItemPk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (CartItem_ItemPk_Field) _Column() string { return "item_pk" }

type OrderedItem struct {
	Pk        int64
	Id        string
	Created   time.Time
	Quantity  int
	Delivered bool
	Price     int
	UserPk    *int64
	ItemPk    int64
	AddressPk int64
}

func (OrderedItem) _Table() string { return "ordered_items" }

type OrderedItem_Create_Fields struct {
	UserPk OrderedItem_UserPk_Field
}

type OrderedItem_Update_Fields struct {
}

type OrderedItem_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func OrderedItem_Pk(v int64) OrderedItem_Pk_Field {
	return OrderedItem_Pk_Field{_set: true, _value: v}
}

func (f OrderedItem_Pk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (OrderedItem_Pk_Field) _Column() string { return "pk" }

type OrderedItem_Id_Field struct {
	_set   bool
	_null  bool
	_value string
}

func OrderedItem_Id(v string) OrderedItem_Id_Field {
	return OrderedItem_Id_Field{_set: true, _value: v}
}

func (f OrderedItem_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (OrderedItem_Id_Field) _Column() string { return "id" }

type OrderedItem_Created_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func OrderedItem_Created(v time.Time) OrderedItem_Created_Field {
	v = toUTC(v)
	return OrderedItem_Created_Field{_set: true, _value: v}
}

func (f OrderedItem_Created_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (OrderedItem_Created_Field) _Column() string { return "created" }

type OrderedItem_Quantity_Field struct {
	_set   bool
	_null  bool
	_value int
}

func OrderedItem_Quantity(v int) OrderedItem_Quantity_Field {
	return OrderedItem_Quantity_Field{_set: true, _value: v}
}

func (f OrderedItem_Quantity_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (OrderedItem_Quantity_Field) _Column() string { return "quantity" }

type OrderedItem_Delivered_Field struct {
	_set   bool
	_null  bool
	_value bool
}

func OrderedItem_Delivered(v bool) OrderedItem_Delivered_Field {
	return OrderedItem_Delivered_Field{_set: true, _value: v}
}

func (f OrderedItem_Delivered_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (OrderedItem_Delivered_Field) _Column() string { return "delivered" }

type OrderedItem_Price_Field struct {
	_set   bool
	_null  bool
	_value int
}

func OrderedItem_Price(v int) OrderedItem_Price_Field {
	return OrderedItem_Price_Field{_set: true, _value: v}
}

func (f OrderedItem_Price_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (OrderedItem_Price_Field) _Column() string { return "price" }

type OrderedItem_UserPk_Field struct {
	_set   bool
	_null  bool
	_value *int64
}

func OrderedItem_UserPk(v int64) OrderedItem_UserPk_Field {
	return OrderedItem_UserPk_Field{_set: true, _value: &v}
}

func OrderedItem_UserPk_Raw(v *int64) OrderedItem_UserPk_Field {
	if v == nil {
		return OrderedItem_UserPk_Null()
	}
	return OrderedItem_UserPk(*v)
}

func OrderedItem_UserPk_Null() OrderedItem_UserPk_Field {
	return OrderedItem_UserPk_Field{_set: true, _null: true}
}

func (f OrderedItem_UserPk_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f OrderedItem_UserPk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (OrderedItem_UserPk_Field) _Column() string { return "user_pk" }

type OrderedItem_ItemPk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func OrderedItem_ItemPk(v int64) OrderedItem_ItemPk_Field {
	return OrderedItem_ItemPk_Field{_set: true, _value: v}
}

func (f OrderedItem_ItemPk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (OrderedItem_ItemPk_Field) _Column() string { return "item_pk" }

type OrderedItem_AddressPk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func OrderedItem_AddressPk(v int64) OrderedItem_AddressPk_Field {
	return OrderedItem_AddressPk_Field{_set: true, _value: v}
}

func (f OrderedItem_AddressPk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (OrderedItem_AddressPk_Field) _Column() string { return "address_pk" }

func toUTC(t time.Time) time.Time {
	return t.UTC()
}

func toDate(t time.Time) time.Time {
	// keep up the minute portion so that translations between timezones will
	// continue to reflect properly.
	return t.Truncate(time.Minute)
}

//
// runtime support for building sql statements
//

type __sqlbundle_SQL interface {
	Render() string

	private()
}

type __sqlbundle_Dialect interface {
	Rebind(sql string) string
}

type __sqlbundle_RenderOp int

const (
	__sqlbundle_NoFlatten __sqlbundle_RenderOp = iota
	__sqlbundle_NoTerminate
)

func __sqlbundle_Render(dialect __sqlbundle_Dialect, sql __sqlbundle_SQL, ops ...__sqlbundle_RenderOp) string {
	out := sql.Render()

	flatten := true
	terminate := true
	for _, op := range ops {
		switch op {
		case __sqlbundle_NoFlatten:
			flatten = false
		case __sqlbundle_NoTerminate:
			terminate = false
		}
	}

	if flatten {
		out = __sqlbundle_flattenSQL(out)
	}
	if terminate {
		out += ";"
	}

	return dialect.Rebind(out)
}

func __sqlbundle_flattenSQL(x string) string {
	// trim whitespace from beginning and end
	s, e := 0, len(x)-1
	for s < len(x) && (x[s] == ' ' || x[s] == '\t' || x[s] == '\n') {
		s++
	}
	for s <= e && (x[e] == ' ' || x[e] == '\t' || x[e] == '\n') {
		e--
	}
	if s > e {
		return ""
	}
	x = x[s : e+1]

	// check for whitespace that needs fixing
	wasSpace := false
	for i := 0; i < len(x); i++ {
		r := x[i]
		justSpace := r == ' '
		if (wasSpace && justSpace) || r == '\t' || r == '\n' {
			// whitespace detected, start writing a new string
			var result strings.Builder
			result.Grow(len(x))
			if wasSpace {
				result.WriteString(x[:i-1])
			} else {
				result.WriteString(x[:i])
			}
			for p := i; p < len(x); p++ {
				for p < len(x) && (x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteByte(' ')

				start := p
				for p < len(x) && !(x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteString(x[start:p])
			}

			return result.String()
		}
		wasSpace = justSpace
	}

	// no problematic whitespace found
	return x
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_postgres struct{}

func (p __sqlbundle_postgres) Rebind(sql string) string {
	out := make([]byte, 0, len(sql)+10)

	j := 1
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		if ch != '?' {
			out = append(out, ch)
			continue
		}

		out = append(out, '$')
		out = append(out, strconv.Itoa(j)...)
		j++
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_sqlite3 struct{}

func (s __sqlbundle_sqlite3) Rebind(sql string) string {
	return sql
}

type __sqlbundle_Literal string

func (__sqlbundle_Literal) private() {}

func (l __sqlbundle_Literal) Render() string { return string(l) }

type __sqlbundle_Literals struct {
	Join string
	SQLs []__sqlbundle_SQL
}

func (__sqlbundle_Literals) private() {}

func (l __sqlbundle_Literals) Render() string {
	var out bytes.Buffer

	first := true
	for _, sql := range l.SQLs {
		if sql == nil {
			continue
		}
		if !first {
			out.WriteString(l.Join)
		}
		first = false
		out.WriteString(sql.Render())
	}

	return out.String()
}

type __sqlbundle_Condition struct {
	// set at compile/embed time
	Name  string
	Left  string
	Equal bool
	Right string

	// set at runtime
	Null bool
}

func (*__sqlbundle_Condition) private() {}

func (c *__sqlbundle_Condition) Render() string {
	// TODO(jeff): maybe check if we can use placeholders instead of the
	// literal null: this would make the templates easier.

	switch {
	case c.Equal && c.Null:
		return c.Left + " is null"
	case c.Equal && !c.Null:
		return c.Left + " = " + c.Right
	case !c.Equal && c.Null:
		return c.Left + " is not null"
	case !c.Equal && !c.Null:
		return c.Left + " != " + c.Right
	default:
		panic("unhandled case")
	}
}

type __sqlbundle_Hole struct {
	// set at compiile/embed time
	Name string

	// set at runtime
	SQL __sqlbundle_SQL
}

func (*__sqlbundle_Hole) private() {}

func (h *__sqlbundle_Hole) Render() string { return h.SQL.Render() }

//
// end runtime support for building sql statements
//

type CartItem_Item_Id_Row struct {
	CartItem CartItem
	Item_Id  string
}

type OrderedItem_Address_Id_Item_Id_Row struct {
	OrderedItem OrderedItem
	Address_Id  string
	Item_Id     string
}

func (obj *postgresImpl) CreateNoReturn_EmailPassword(ctx context.Context,
	email_password_email EmailPassword_Email_Field,
	email_password_password_hash EmailPassword_PasswordHash_Field,
	email_password_code EmailPassword_Code_Field) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__email_val := email_password_email.value()
	__password_hash_val := email_password_password_hash.value()
	__created_val := __now.UTC()
	__passowrd_updated_val := __now.UTC()
	__last_login_val := __now.UTC()
	__code_val := email_password_code.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO email_passwords ( email, password_hash, created, passowrd_updated, last_login, code ) VALUES ( ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __email_val, __password_hash_val, __created_val, __passowrd_updated_val, __last_login_val, __code_val)

	_, err = obj.driver.Exec(__stmt, __email_val, __password_hash_val, __created_val, __passowrd_updated_val, __last_login_val, __code_val)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *postgresImpl) Create_User(ctx context.Context,
	user_id User_Id_Field,
	user_email User_Email_Field,
	user_profile_url User_ProfileUrl_Field,
	user_full_name User_FullName_Field) (
	user *User, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := user_id.value()
	__email_val := user_email.value()
	__created_val := __now.UTC()
	__profile_url_val := user_profile_url.value()
	__full_name_val := user_full_name.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO users ( id, email, created, profile_url, full_name ) VALUES ( ?, ?, ?, ?, ? ) RETURNING users.pk, users.id, users.email, users.created, users.profile_url, users.full_name")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __email_val, __created_val, __profile_url_val, __full_name_val)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __id_val, __email_val, __created_val, __profile_url_val, __full_name_val).Scan(&user.Pk, &user.Id, &user.Email, &user.Created, &user.ProfileUrl, &user.FullName)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *postgresImpl) Create_Session(ctx context.Context,
	session_id Session_Id_Field,
	session_id_token Session_IdToken_Field,
	session_access_token Session_AccessToken_Field,
	session_refresh_token Session_RefreshToken_Field,
	session_access_token_expiry Session_AccessTokenExpiry_Field,
	session_device_name Session_DeviceName_Field,
	optional Session_Create_Fields) (
	session *Session, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := session_id.value()
	__created_val := __now.UTC()
	__id_token_val := session_id_token.value()
	__access_token_val := session_access_token.value()
	__refresh_token_val := session_refresh_token.value()
	__access_token_expiry_val := session_access_token_expiry.value()
	__device_name_val := session_device_name.value()
	__user_pk_val := optional.UserPk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO sessions ( id, created, id_token, access_token, refresh_token, access_token_expiry, device_name, user_pk ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING sessions.pk, sessions.id, sessions.created, sessions.id_token, sessions.access_token, sessions.refresh_token, sessions.access_token_expiry, sessions.device_name, sessions.user_pk")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __created_val, __id_token_val, __access_token_val, __refresh_token_val, __access_token_expiry_val, __device_name_val, __user_pk_val)

	session = &Session{}
	err = obj.driver.QueryRow(__stmt, __id_val, __created_val, __id_token_val, __access_token_val, __refresh_token_val, __access_token_expiry_val, __device_name_val, __user_pk_val).Scan(&session.Pk, &session.Id, &session.Created, &session.IdToken, &session.AccessToken, &session.RefreshToken, &session.AccessTokenExpiry, &session.DeviceName, &session.UserPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return session, nil

}

func (obj *postgresImpl) Create_Address(ctx context.Context,
	address_id Address_Id_Field,
	address_line1 Address_Line1_Field,
	address_line2 Address_Line2_Field,
	address_line3 Address_Line3_Field,
	address_country Address_Country_Field,
	address_state Address_State_Field,
	address_city Address_City_Field,
	address_zip Address_Zip_Field,
	address_phone Address_Phone_Field,
	address_notes Address_Notes_Field,
	optional Address_Create_Fields) (
	address *Address, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := address_id.value()
	__created_val := __now.UTC()
	__line1_val := address_line1.value()
	__line2_val := address_line2.value()
	__line3_val := address_line3.value()
	__country_val := address_country.value()
	__state_val := address_state.value()
	__city_val := address_city.value()
	__zip_val := address_zip.value()
	__phone_val := address_phone.value()
	__notes_val := address_notes.value()
	__user_pk_val := optional.UserPk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO addresses ( id, created, line1, line2, line3, country, state, city, zip, phone, notes, user_pk ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING addresses.pk, addresses.id, addresses.created, addresses.line1, addresses.line2, addresses.line3, addresses.country, addresses.state, addresses.city, addresses.zip, addresses.phone, addresses.notes, addresses.user_pk")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __created_val, __line1_val, __line2_val, __line3_val, __country_val, __state_val, __city_val, __zip_val, __phone_val, __notes_val, __user_pk_val)

	address = &Address{}
	err = obj.driver.QueryRow(__stmt, __id_val, __created_val, __line1_val, __line2_val, __line3_val, __country_val, __state_val, __city_val, __zip_val, __phone_val, __notes_val, __user_pk_val).Scan(&address.Pk, &address.Id, &address.Created, &address.Line1, &address.Line2, &address.Line3, &address.Country, &address.State, &address.City, &address.Zip, &address.Phone, &address.Notes, &address.UserPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return address, nil

}

func (obj *postgresImpl) Create_Item(ctx context.Context,
	item_id Item_Id_Field,
	item_price Item_Price_Field,
	item_description Item_Description_Field,
	item_image_url Item_ImageUrl_Field,
	item_remaining_quantity Item_RemainingQuantity_Field,
	optional Item_Create_Fields) (
	item *Item, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := item_id.value()
	__created_val := __now.UTC()
	__price_val := item_price.value()
	__description_val := item_description.value()
	__image_url_val := item_image_url.value()
	__remaining_quantity_val := item_remaining_quantity.value()
	__owning_user_pk_val := optional.OwningUserPk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO items ( id, created, price, description, image_url, remaining_quantity, owning_user_pk ) VALUES ( ?, ?, ?, ?, ?, ?, ? ) RETURNING items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __created_val, __price_val, __description_val, __image_url_val, __remaining_quantity_val, __owning_user_pk_val)

	item = &Item{}
	err = obj.driver.QueryRow(__stmt, __id_val, __created_val, __price_val, __description_val, __image_url_val, __remaining_quantity_val, __owning_user_pk_val).Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return item, nil

}

func (obj *postgresImpl) CreateNoReturn_CartItem(ctx context.Context,
	cart_item_id CartItem_Id_Field,
	cart_item_quantity CartItem_Quantity_Field,
	optional CartItem_Create_Fields) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := cart_item_id.value()
	__created_val := __now.UTC()
	__quantity_val := cart_item_quantity.value()
	__user_pk_val := optional.UserPk.value()
	__item_pk_val := optional.ItemPk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO cart_items ( id, created, quantity, user_pk, item_pk ) VALUES ( ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __created_val, __quantity_val, __user_pk_val, __item_pk_val)

	_, err = obj.driver.Exec(__stmt, __id_val, __created_val, __quantity_val, __user_pk_val, __item_pk_val)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *postgresImpl) CreateNoReturn_OrderedItem(ctx context.Context,
	ordered_item_id OrderedItem_Id_Field,
	ordered_item_quantity OrderedItem_Quantity_Field,
	ordered_item_delivered OrderedItem_Delivered_Field,
	ordered_item_price OrderedItem_Price_Field,
	ordered_item_item_pk OrderedItem_ItemPk_Field,
	ordered_item_address_pk OrderedItem_AddressPk_Field,
	optional OrderedItem_Create_Fields) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := ordered_item_id.value()
	__created_val := __now.UTC()
	__quantity_val := ordered_item_quantity.value()
	__delivered_val := ordered_item_delivered.value()
	__price_val := ordered_item_price.value()
	__user_pk_val := optional.UserPk.value()
	__item_pk_val := ordered_item_item_pk.value()
	__address_pk_val := ordered_item_address_pk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO ordered_items ( id, created, quantity, delivered, price, user_pk, item_pk, address_pk ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __created_val, __quantity_val, __delivered_val, __price_val, __user_pk_val, __item_pk_val, __address_pk_val)

	_, err = obj.driver.Exec(__stmt, __id_val, __created_val, __quantity_val, __delivered_val, __price_val, __user_pk_val, __item_pk_val, __address_pk_val)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *postgresImpl) Find_EmailPassword_By_Email_And_PasswordHash(ctx context.Context,
	email_password_email EmailPassword_Email_Field,
	email_password_password_hash EmailPassword_PasswordHash_Field) (
	email_password *EmailPassword, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT email_passwords.pk, email_passwords.email, email_passwords.password_hash, email_passwords.created, email_passwords.passowrd_updated, email_passwords.last_login, email_passwords.code FROM email_passwords WHERE email_passwords.email = ? AND email_passwords.password_hash = ?")

	var __values []interface{}
	__values = append(__values, email_password_email.value(), email_password_password_hash.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	email_password = &EmailPassword{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&email_password.Pk, &email_password.Email, &email_password.PasswordHash, &email_password.Created, &email_password.PassowrdUpdated, &email_password.LastLogin, &email_password.Code)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return email_password, nil

}

func (obj *postgresImpl) Find_EmailPassword_By_Code_And_LastLogin_Greater(ctx context.Context,
	email_password_code EmailPassword_Code_Field,
	email_password_last_login_greater EmailPassword_LastLogin_Field) (
	email_password *EmailPassword, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT email_passwords.pk, email_passwords.email, email_passwords.password_hash, email_passwords.created, email_passwords.passowrd_updated, email_passwords.last_login, email_passwords.code FROM email_passwords WHERE email_passwords.code = ? AND email_passwords.last_login > ? LIMIT 2")

	var __values []interface{}
	__values = append(__values, email_password_code.value(), email_password_last_login_greater.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	email_password = &EmailPassword{}
	err = __rows.Scan(&email_password.Pk, &email_password.Email, &email_password.PasswordHash, &email_password.Created, &email_password.PassowrdUpdated, &email_password.LastLogin, &email_password.Code)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("EmailPassword_By_Code_And_LastLogin_Greater")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return email_password, nil

}

func (obj *postgresImpl) Find_User_By_Email(ctx context.Context,
	user_email User_Email_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.pk, users.id, users.email, users.created, users.profile_url, users.full_name FROM users WHERE users.email = ?")

	var __values []interface{}
	__values = append(__values, user_email.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Pk, &user.Id, &user.Email, &user.Created, &user.ProfileUrl, &user.FullName)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *postgresImpl) Find_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.pk, users.id, users.email, users.created, users.profile_url, users.full_name FROM users WHERE users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Pk, &user.Id, &user.Email, &user.Created, &user.ProfileUrl, &user.FullName)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *postgresImpl) Find_User_By_Session_Id(ctx context.Context,
	session_id Session_Id_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.pk, users.id, users.email, users.created, users.profile_url, users.full_name FROM users  JOIN sessions ON users.pk = sessions.user_pk WHERE sessions.id = ?")

	var __values []interface{}
	__values = append(__values, session_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Pk, &user.Id, &user.Email, &user.Created, &user.ProfileUrl, &user.FullName)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *postgresImpl) Find_User_By_Session_AccessToken(ctx context.Context,
	session_access_token Session_AccessToken_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.pk, users.id, users.email, users.created, users.profile_url, users.full_name FROM users  JOIN sessions ON users.pk = sessions.user_pk WHERE sessions.access_token = ?")

	var __values []interface{}
	__values = append(__values, session_access_token.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Pk, &user.Id, &user.Email, &user.Created, &user.ProfileUrl, &user.FullName)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *postgresImpl) All_Session_By_User_Id_OrderBy_Desc_Session_Created(ctx context.Context,
	user_id User_Id_Field) (
	rows []*Session, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT sessions.pk, sessions.id, sessions.created, sessions.id_token, sessions.access_token, sessions.refresh_token, sessions.access_token_expiry, sessions.device_name, sessions.user_pk FROM sessions  JOIN users ON sessions.user_pk = users.pk WHERE users.id = ? ORDER BY sessions.created DESC")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		session := &Session{}
		err = __rows.Scan(&session.Pk, &session.Id, &session.Created, &session.IdToken, &session.AccessToken, &session.RefreshToken, &session.AccessTokenExpiry, &session.DeviceName, &session.UserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, session)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Find_Session_By_AccessToken(ctx context.Context,
	session_access_token Session_AccessToken_Field) (
	session *Session, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT sessions.pk, sessions.id, sessions.created, sessions.id_token, sessions.access_token, sessions.refresh_token, sessions.access_token_expiry, sessions.device_name, sessions.user_pk FROM sessions WHERE sessions.access_token = ?")

	var __values []interface{}
	__values = append(__values, session_access_token.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	session = &Session{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&session.Pk, &session.Id, &session.Created, &session.IdToken, &session.AccessToken, &session.RefreshToken, &session.AccessTokenExpiry, &session.DeviceName, &session.UserPk)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return session, nil

}

func (obj *postgresImpl) Get_Address_By_Id(ctx context.Context,
	address_id Address_Id_Field) (
	address *Address, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT addresses.pk, addresses.id, addresses.created, addresses.line1, addresses.line2, addresses.line3, addresses.country, addresses.state, addresses.city, addresses.zip, addresses.phone, addresses.notes, addresses.user_pk FROM addresses WHERE addresses.id = ?")

	var __values []interface{}
	__values = append(__values, address_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	address = &Address{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&address.Pk, &address.Id, &address.Created, &address.Line1, &address.Line2, &address.Line3, &address.Country, &address.State, &address.City, &address.Zip, &address.Phone, &address.Notes, &address.UserPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return address, nil

}

func (obj *postgresImpl) All_Address_By_UserPk(ctx context.Context,
	address_user_pk Address_UserPk_Field) (
	rows []*Address, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "addresses.user_pk", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT addresses.pk, addresses.id, addresses.created, addresses.line1, addresses.line2, addresses.line3, addresses.country, addresses.state, addresses.city, addresses.zip, addresses.phone, addresses.notes, addresses.user_pk FROM addresses WHERE "), __cond_0}}

	var __values []interface{}
	__values = append(__values)

	if !address_user_pk.isnull() {
		__cond_0.Null = false
		__values = append(__values, address_user_pk.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		address := &Address{}
		err = __rows.Scan(&address.Pk, &address.Id, &address.Created, &address.Line1, &address.Line2, &address.Line3, &address.Country, &address.State, &address.City, &address.Zip, &address.Phone, &address.Notes, &address.UserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, address)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_Address_By_User_Id(ctx context.Context,
	user_id User_Id_Field) (
	rows []*Address, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT addresses.pk, addresses.id, addresses.created, addresses.line1, addresses.line2, addresses.line3, addresses.country, addresses.state, addresses.city, addresses.zip, addresses.phone, addresses.notes, addresses.user_pk FROM addresses  JOIN users ON addresses.user_pk = users.pk WHERE users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		address := &Address{}
		err = __rows.Scan(&address.Pk, &address.Id, &address.Created, &address.Line1, &address.Line2, &address.Line3, &address.Country, &address.State, &address.City, &address.Zip, &address.Phone, &address.Notes, &address.UserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, address)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_Item(ctx context.Context) (
	rows []*Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items ORDER BY items.created DESC")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		item := &Item{}
		err = __rows.Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, item)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_Unavailable_Item(ctx context.Context) (
	rows []*Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items WHERE items.remaining_quantity = 0 ORDER BY items.created DESC")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		item := &Item{}
		err = __rows.Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, item)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_Available_Item(ctx context.Context) (
	rows []*Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items WHERE items.remaining_quantity > 0 ORDER BY items.created DESC")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		item := &Item{}
		err = __rows.Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, item)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_Item_By_Pk(ctx context.Context,
	item_pk Item_Pk_Field) (
	item *Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items WHERE items.pk = ?")

	var __values []interface{}
	__values = append(__values, item_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	item = &Item{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return item, nil

}

func (obj *postgresImpl) Find_Item_By_Id_And_RemainingQuantity_GreaterOrEqual(ctx context.Context,
	item_id Item_Id_Field,
	item_remaining_quantity_greater_or_equal Item_RemainingQuantity_Field) (
	item *Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items WHERE items.id = ? AND items.remaining_quantity >= ?")

	var __values []interface{}
	__values = append(__values, item_id.value(), item_remaining_quantity_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	item = &Item{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return item, nil

}

func (obj *postgresImpl) All_Item_By_RemainingQuantity_Greater_Number_And_Created_GreaterOrEqual(ctx context.Context,
	item_created_greater_or_equal Item_Created_Field) (
	rows []*Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items WHERE items.remaining_quantity > 0 AND items.created >= ?")

	var __values []interface{}
	__values = append(__values, item_created_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		item := &Item{}
		err = __rows.Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, item)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_Item_By_Item_RemainingQuantity_Greater_Number_And_User_Id(ctx context.Context,
	user_id User_Id_Field) (
	rows []*Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items  JOIN users ON items.owning_user_pk = users.pk WHERE items.remaining_quantity > 0 AND users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		item := &Item{}
		err = __rows.Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, item)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_CartItem_ItemId_By_SessionId(ctx context.Context,
	session_id Session_Id_Field) (
	rows []*CartItem_Item_Id_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT cart_items.pk, cart_items.id, cart_items.created, cart_items.quantity, cart_items.user_pk, cart_items.item_pk, items.id FROM cart_items  JOIN sessions ON cart_items.user_pk = sessions.user_pk  JOIN items ON cart_items.item_pk = items.pk WHERE sessions.id = ? ORDER BY cart_items.created DESC")

	var __values []interface{}
	__values = append(__values, session_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &CartItem_Item_Id_Row{}
		err = __rows.Scan(&row.CartItem.Pk, &row.CartItem.Id, &row.CartItem.Created, &row.CartItem.Quantity, &row.CartItem.UserPk, &row.CartItem.ItemPk, &row.Item_Id)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Find_CartItem_By_Item_Id_And_CartItem_UserPk(ctx context.Context,
	item_id Item_Id_Field,
	cart_item_user_pk CartItem_UserPk_Field) (
	cart_item *CartItem, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "cart_items.user_pk", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT cart_items.pk, cart_items.id, cart_items.created, cart_items.quantity, cart_items.user_pk, cart_items.item_pk FROM cart_items  JOIN items ON cart_items.item_pk = items.pk WHERE items.id = ? AND "), __cond_0, __sqlbundle_Literal(" LIMIT 2")}}

	var __values []interface{}
	__values = append(__values, item_id.value())

	if !cart_item_user_pk.isnull() {
		__cond_0.Null = false
		__values = append(__values, cart_item_user_pk.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	cart_item = &CartItem{}
	err = __rows.Scan(&cart_item.Pk, &cart_item.Id, &cart_item.Created, &cart_item.Quantity, &cart_item.UserPk, &cart_item.ItemPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("CartItem_By_Item_Id_And_CartItem_UserPk")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return cart_item, nil

}

func (obj *postgresImpl) Get_CartItem_By_Item_Id_And_CartItem_UserPk(ctx context.Context,
	item_id Item_Id_Field,
	cart_item_user_pk CartItem_UserPk_Field) (
	cart_item *CartItem, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "cart_items.user_pk", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT cart_items.pk, cart_items.id, cart_items.created, cart_items.quantity, cart_items.user_pk, cart_items.item_pk FROM cart_items  JOIN items ON cart_items.item_pk = items.pk WHERE items.id = ? AND "), __cond_0, __sqlbundle_Literal(" LIMIT 2")}}

	var __values []interface{}
	__values = append(__values, item_id.value())

	if !cart_item_user_pk.isnull() {
		__cond_0.Null = false
		__values = append(__values, cart_item_user_pk.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, makeErr(sql.ErrNoRows)
	}

	cart_item = &CartItem{}
	err = __rows.Scan(&cart_item.Pk, &cart_item.Id, &cart_item.Created, &cart_item.Quantity, &cart_item.UserPk, &cart_item.ItemPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("CartItem_By_Item_Id_And_CartItem_UserPk")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return cart_item, nil

}

func (obj *postgresImpl) All_OrderedItem_AddressId_ItemId_By_SessionId(ctx context.Context,
	session_id Session_Id_Field) (
	rows []*OrderedItem_Address_Id_Item_Id_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ordered_items.pk, ordered_items.id, ordered_items.created, ordered_items.quantity, ordered_items.delivered, ordered_items.price, ordered_items.user_pk, ordered_items.item_pk, ordered_items.address_pk, addresses.id, items.id FROM ordered_items  JOIN sessions ON ordered_items.user_pk = sessions.user_pk  JOIN addresses ON ordered_items.address_pk = addresses.pk  JOIN items ON ordered_items.item_pk = items.pk WHERE sessions.id = ? ORDER BY ordered_items.delivered, ordered_items.created DESC")

	var __values []interface{}
	__values = append(__values, session_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &OrderedItem_Address_Id_Item_Id_Row{}
		err = __rows.Scan(&row.OrderedItem.Pk, &row.OrderedItem.Id, &row.OrderedItem.Created, &row.OrderedItem.Quantity, &row.OrderedItem.Delivered, &row.OrderedItem.Price, &row.OrderedItem.UserPk, &row.OrderedItem.ItemPk, &row.OrderedItem.AddressPk, &row.Address_Id, &row.Item_Id)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) UpdateNoReturn_EmailPassword_By_Pk(ctx context.Context,
	email_password_pk EmailPassword_Pk_Field,
	update EmailPassword_Update_Fields) (
	err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE email_passwords SET "), __sets, __sqlbundle_Literal(" WHERE email_passwords.pk = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Email._set {
		__values = append(__values, update.Email.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("email = ?"))
	}

	if update.PasswordHash._set {
		__values = append(__values, update.PasswordHash.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("password_hash = ?"))
	}

	if update.PassowrdUpdated._set {
		__values = append(__values, update.PassowrdUpdated.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("passowrd_updated = ?"))
	}

	if update.Code._set {
		__values = append(__values, update.Code.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("code = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_login = ?"))

	__args = append(__args, email_password_pk.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *postgresImpl) Update_Item_By_Pk(ctx context.Context,
	item_pk Item_Pk_Field,
	update Item_Update_Fields) (
	item *Item, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE items SET "), __sets, __sqlbundle_Literal(" WHERE items.pk = ? RETURNING items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Price._set {
		__values = append(__values, update.Price.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("price = ?"))
	}

	if update.Description._set {
		__values = append(__values, update.Description.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("description = ?"))
	}

	if update.ImageUrl._set {
		__values = append(__values, update.ImageUrl.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("image_url = ?"))
	}

	if update.RemainingQuantity._set {
		__values = append(__values, update.RemainingQuantity.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("remaining_quantity = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, item_pk.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	item = &Item{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return item, nil
}

func (obj *postgresImpl) UpdateNoReturn_Item_By_Pk(ctx context.Context,
	item_pk Item_Pk_Field,
	update Item_Update_Fields) (
	err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE items SET "), __sets, __sqlbundle_Literal(" WHERE items.pk = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Price._set {
		__values = append(__values, update.Price.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("price = ?"))
	}

	if update.Description._set {
		__values = append(__values, update.Description.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("description = ?"))
	}

	if update.ImageUrl._set {
		__values = append(__values, update.ImageUrl.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("image_url = ?"))
	}

	if update.RemainingQuantity._set {
		__values = append(__values, update.RemainingQuantity.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("remaining_quantity = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return emptyUpdate()
	}

	__args = append(__args, item_pk.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *postgresImpl) Update_Item_By_Id_And_OwningUserPk(ctx context.Context,
	item_id Item_Id_Field,
	item_owning_user_pk Item_OwningUserPk_Field,
	update Item_Update_Fields) (
	item *Item, err error) {
	var __sets = &__sqlbundle_Hole{}
	var __cond_0 = &__sqlbundle_Condition{Left: "items.owning_user_pk", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE items SET "), __sets, __sqlbundle_Literal(" WHERE items.id = ? AND "), __cond_0, __sqlbundle_Literal(" RETURNING items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Price._set {
		__values = append(__values, update.Price.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("price = ?"))
	}

	if update.Description._set {
		__values = append(__values, update.Description.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("description = ?"))
	}

	if update.ImageUrl._set {
		__values = append(__values, update.ImageUrl.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("image_url = ?"))
	}

	if update.RemainingQuantity._set {
		__values = append(__values, update.RemainingQuantity.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("remaining_quantity = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, item_id.value())

	if !item_owning_user_pk.isnull() {
		__cond_0.Null = false
		__args = append(__args, item_owning_user_pk.value())
	}

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	item = &Item{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return item, nil
}

func (obj *postgresImpl) Update_CartItem_By_Pk(ctx context.Context,
	cart_item_pk CartItem_Pk_Field,
	update CartItem_Update_Fields) (
	cart_item *CartItem, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE cart_items SET "), __sets, __sqlbundle_Literal(" WHERE cart_items.pk = ? RETURNING cart_items.pk, cart_items.id, cart_items.created, cart_items.quantity, cart_items.user_pk, cart_items.item_pk")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Quantity._set {
		__values = append(__values, update.Quantity.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("quantity = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, cart_item_pk.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	cart_item = &CartItem{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&cart_item.Pk, &cart_item.Id, &cart_item.Created, &cart_item.Quantity, &cart_item.UserPk, &cart_item.ItemPk)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return cart_item, nil
}

func (obj *postgresImpl) UpdateNoReturn_CartItem_By_Pk(ctx context.Context,
	cart_item_pk CartItem_Pk_Field,
	update CartItem_Update_Fields) (
	err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE cart_items SET "), __sets, __sqlbundle_Literal(" WHERE cart_items.pk = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Quantity._set {
		__values = append(__values, update.Quantity.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("quantity = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return emptyUpdate()
	}

	__args = append(__args, cart_item_pk.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *postgresImpl) Delete_Session_By_Pk(ctx context.Context,
	session_pk Session_Pk_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM sessions WHERE sessions.pk = ?")

	var __values []interface{}
	__values = append(__values, session_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_CartItem_By_Pk(ctx context.Context,
	cart_item_pk CartItem_Pk_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM cart_items WHERE cart_items.pk = ?")

	var __values []interface{}
	__values = append(__values, cart_item_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (impl postgresImpl) isConstraintError(err error) (
	constraint string, ok bool) {
	if e, ok := err.(*pq.Error); ok {
		if e.Code.Class() == "23" {
			return e.Constraint, true
		}
	}
	return "", false
}

func (obj *postgresImpl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.Exec("DELETE FROM ordered_items;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM cart_items;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM sessions;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM items;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM addresses;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM users;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM email_passwords;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

func (obj *sqlite3Impl) CreateNoReturn_EmailPassword(ctx context.Context,
	email_password_email EmailPassword_Email_Field,
	email_password_password_hash EmailPassword_PasswordHash_Field,
	email_password_code EmailPassword_Code_Field) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__email_val := email_password_email.value()
	__password_hash_val := email_password_password_hash.value()
	__created_val := __now.UTC()
	__passowrd_updated_val := __now.UTC()
	__last_login_val := __now.UTC()
	__code_val := email_password_code.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO email_passwords ( email, password_hash, created, passowrd_updated, last_login, code ) VALUES ( ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __email_val, __password_hash_val, __created_val, __passowrd_updated_val, __last_login_val, __code_val)

	_, err = obj.driver.Exec(__stmt, __email_val, __password_hash_val, __created_val, __passowrd_updated_val, __last_login_val, __code_val)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *sqlite3Impl) Create_User(ctx context.Context,
	user_id User_Id_Field,
	user_email User_Email_Field,
	user_profile_url User_ProfileUrl_Field,
	user_full_name User_FullName_Field) (
	user *User, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := user_id.value()
	__email_val := user_email.value()
	__created_val := __now.UTC()
	__profile_url_val := user_profile_url.value()
	__full_name_val := user_full_name.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO users ( id, email, created, profile_url, full_name ) VALUES ( ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __email_val, __created_val, __profile_url_val, __full_name_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __email_val, __created_val, __profile_url_val, __full_name_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastUser(ctx, __pk)

}

func (obj *sqlite3Impl) Create_Session(ctx context.Context,
	session_id Session_Id_Field,
	session_id_token Session_IdToken_Field,
	session_access_token Session_AccessToken_Field,
	session_refresh_token Session_RefreshToken_Field,
	session_access_token_expiry Session_AccessTokenExpiry_Field,
	session_device_name Session_DeviceName_Field,
	optional Session_Create_Fields) (
	session *Session, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := session_id.value()
	__created_val := __now.UTC()
	__id_token_val := session_id_token.value()
	__access_token_val := session_access_token.value()
	__refresh_token_val := session_refresh_token.value()
	__access_token_expiry_val := session_access_token_expiry.value()
	__device_name_val := session_device_name.value()
	__user_pk_val := optional.UserPk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO sessions ( id, created, id_token, access_token, refresh_token, access_token_expiry, device_name, user_pk ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __created_val, __id_token_val, __access_token_val, __refresh_token_val, __access_token_expiry_val, __device_name_val, __user_pk_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __created_val, __id_token_val, __access_token_val, __refresh_token_val, __access_token_expiry_val, __device_name_val, __user_pk_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastSession(ctx, __pk)

}

func (obj *sqlite3Impl) Create_Address(ctx context.Context,
	address_id Address_Id_Field,
	address_line1 Address_Line1_Field,
	address_line2 Address_Line2_Field,
	address_line3 Address_Line3_Field,
	address_country Address_Country_Field,
	address_state Address_State_Field,
	address_city Address_City_Field,
	address_zip Address_Zip_Field,
	address_phone Address_Phone_Field,
	address_notes Address_Notes_Field,
	optional Address_Create_Fields) (
	address *Address, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := address_id.value()
	__created_val := __now.UTC()
	__line1_val := address_line1.value()
	__line2_val := address_line2.value()
	__line3_val := address_line3.value()
	__country_val := address_country.value()
	__state_val := address_state.value()
	__city_val := address_city.value()
	__zip_val := address_zip.value()
	__phone_val := address_phone.value()
	__notes_val := address_notes.value()
	__user_pk_val := optional.UserPk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO addresses ( id, created, line1, line2, line3, country, state, city, zip, phone, notes, user_pk ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __created_val, __line1_val, __line2_val, __line3_val, __country_val, __state_val, __city_val, __zip_val, __phone_val, __notes_val, __user_pk_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __created_val, __line1_val, __line2_val, __line3_val, __country_val, __state_val, __city_val, __zip_val, __phone_val, __notes_val, __user_pk_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastAddress(ctx, __pk)

}

func (obj *sqlite3Impl) Create_Item(ctx context.Context,
	item_id Item_Id_Field,
	item_price Item_Price_Field,
	item_description Item_Description_Field,
	item_image_url Item_ImageUrl_Field,
	item_remaining_quantity Item_RemainingQuantity_Field,
	optional Item_Create_Fields) (
	item *Item, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := item_id.value()
	__created_val := __now.UTC()
	__price_val := item_price.value()
	__description_val := item_description.value()
	__image_url_val := item_image_url.value()
	__remaining_quantity_val := item_remaining_quantity.value()
	__owning_user_pk_val := optional.OwningUserPk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO items ( id, created, price, description, image_url, remaining_quantity, owning_user_pk ) VALUES ( ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __created_val, __price_val, __description_val, __image_url_val, __remaining_quantity_val, __owning_user_pk_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __created_val, __price_val, __description_val, __image_url_val, __remaining_quantity_val, __owning_user_pk_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastItem(ctx, __pk)

}

func (obj *sqlite3Impl) CreateNoReturn_CartItem(ctx context.Context,
	cart_item_id CartItem_Id_Field,
	cart_item_quantity CartItem_Quantity_Field,
	optional CartItem_Create_Fields) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := cart_item_id.value()
	__created_val := __now.UTC()
	__quantity_val := cart_item_quantity.value()
	__user_pk_val := optional.UserPk.value()
	__item_pk_val := optional.ItemPk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO cart_items ( id, created, quantity, user_pk, item_pk ) VALUES ( ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __created_val, __quantity_val, __user_pk_val, __item_pk_val)

	_, err = obj.driver.Exec(__stmt, __id_val, __created_val, __quantity_val, __user_pk_val, __item_pk_val)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *sqlite3Impl) CreateNoReturn_OrderedItem(ctx context.Context,
	ordered_item_id OrderedItem_Id_Field,
	ordered_item_quantity OrderedItem_Quantity_Field,
	ordered_item_delivered OrderedItem_Delivered_Field,
	ordered_item_price OrderedItem_Price_Field,
	ordered_item_item_pk OrderedItem_ItemPk_Field,
	ordered_item_address_pk OrderedItem_AddressPk_Field,
	optional OrderedItem_Create_Fields) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := ordered_item_id.value()
	__created_val := __now.UTC()
	__quantity_val := ordered_item_quantity.value()
	__delivered_val := ordered_item_delivered.value()
	__price_val := ordered_item_price.value()
	__user_pk_val := optional.UserPk.value()
	__item_pk_val := ordered_item_item_pk.value()
	__address_pk_val := ordered_item_address_pk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO ordered_items ( id, created, quantity, delivered, price, user_pk, item_pk, address_pk ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __created_val, __quantity_val, __delivered_val, __price_val, __user_pk_val, __item_pk_val, __address_pk_val)

	_, err = obj.driver.Exec(__stmt, __id_val, __created_val, __quantity_val, __delivered_val, __price_val, __user_pk_val, __item_pk_val, __address_pk_val)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *sqlite3Impl) Find_EmailPassword_By_Email_And_PasswordHash(ctx context.Context,
	email_password_email EmailPassword_Email_Field,
	email_password_password_hash EmailPassword_PasswordHash_Field) (
	email_password *EmailPassword, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT email_passwords.pk, email_passwords.email, email_passwords.password_hash, email_passwords.created, email_passwords.passowrd_updated, email_passwords.last_login, email_passwords.code FROM email_passwords WHERE email_passwords.email = ? AND email_passwords.password_hash = ?")

	var __values []interface{}
	__values = append(__values, email_password_email.value(), email_password_password_hash.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	email_password = &EmailPassword{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&email_password.Pk, &email_password.Email, &email_password.PasswordHash, &email_password.Created, &email_password.PassowrdUpdated, &email_password.LastLogin, &email_password.Code)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return email_password, nil

}

func (obj *sqlite3Impl) Find_EmailPassword_By_Code_And_LastLogin_Greater(ctx context.Context,
	email_password_code EmailPassword_Code_Field,
	email_password_last_login_greater EmailPassword_LastLogin_Field) (
	email_password *EmailPassword, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT email_passwords.pk, email_passwords.email, email_passwords.password_hash, email_passwords.created, email_passwords.passowrd_updated, email_passwords.last_login, email_passwords.code FROM email_passwords WHERE email_passwords.code = ? AND email_passwords.last_login > ? LIMIT 2")

	var __values []interface{}
	__values = append(__values, email_password_code.value(), email_password_last_login_greater.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	email_password = &EmailPassword{}
	err = __rows.Scan(&email_password.Pk, &email_password.Email, &email_password.PasswordHash, &email_password.Created, &email_password.PassowrdUpdated, &email_password.LastLogin, &email_password.Code)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("EmailPassword_By_Code_And_LastLogin_Greater")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return email_password, nil

}

func (obj *sqlite3Impl) Find_User_By_Email(ctx context.Context,
	user_email User_Email_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.pk, users.id, users.email, users.created, users.profile_url, users.full_name FROM users WHERE users.email = ?")

	var __values []interface{}
	__values = append(__values, user_email.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Pk, &user.Id, &user.Email, &user.Created, &user.ProfileUrl, &user.FullName)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *sqlite3Impl) Find_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.pk, users.id, users.email, users.created, users.profile_url, users.full_name FROM users WHERE users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Pk, &user.Id, &user.Email, &user.Created, &user.ProfileUrl, &user.FullName)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *sqlite3Impl) Find_User_By_Session_Id(ctx context.Context,
	session_id Session_Id_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.pk, users.id, users.email, users.created, users.profile_url, users.full_name FROM users  JOIN sessions ON users.pk = sessions.user_pk WHERE sessions.id = ?")

	var __values []interface{}
	__values = append(__values, session_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Pk, &user.Id, &user.Email, &user.Created, &user.ProfileUrl, &user.FullName)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *sqlite3Impl) Find_User_By_Session_AccessToken(ctx context.Context,
	session_access_token Session_AccessToken_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.pk, users.id, users.email, users.created, users.profile_url, users.full_name FROM users  JOIN sessions ON users.pk = sessions.user_pk WHERE sessions.access_token = ?")

	var __values []interface{}
	__values = append(__values, session_access_token.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Pk, &user.Id, &user.Email, &user.Created, &user.ProfileUrl, &user.FullName)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *sqlite3Impl) All_Session_By_User_Id_OrderBy_Desc_Session_Created(ctx context.Context,
	user_id User_Id_Field) (
	rows []*Session, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT sessions.pk, sessions.id, sessions.created, sessions.id_token, sessions.access_token, sessions.refresh_token, sessions.access_token_expiry, sessions.device_name, sessions.user_pk FROM sessions  JOIN users ON sessions.user_pk = users.pk WHERE users.id = ? ORDER BY sessions.created DESC")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		session := &Session{}
		err = __rows.Scan(&session.Pk, &session.Id, &session.Created, &session.IdToken, &session.AccessToken, &session.RefreshToken, &session.AccessTokenExpiry, &session.DeviceName, &session.UserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, session)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Find_Session_By_AccessToken(ctx context.Context,
	session_access_token Session_AccessToken_Field) (
	session *Session, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT sessions.pk, sessions.id, sessions.created, sessions.id_token, sessions.access_token, sessions.refresh_token, sessions.access_token_expiry, sessions.device_name, sessions.user_pk FROM sessions WHERE sessions.access_token = ?")

	var __values []interface{}
	__values = append(__values, session_access_token.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	session = &Session{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&session.Pk, &session.Id, &session.Created, &session.IdToken, &session.AccessToken, &session.RefreshToken, &session.AccessTokenExpiry, &session.DeviceName, &session.UserPk)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return session, nil

}

func (obj *sqlite3Impl) Get_Address_By_Id(ctx context.Context,
	address_id Address_Id_Field) (
	address *Address, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT addresses.pk, addresses.id, addresses.created, addresses.line1, addresses.line2, addresses.line3, addresses.country, addresses.state, addresses.city, addresses.zip, addresses.phone, addresses.notes, addresses.user_pk FROM addresses WHERE addresses.id = ?")

	var __values []interface{}
	__values = append(__values, address_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	address = &Address{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&address.Pk, &address.Id, &address.Created, &address.Line1, &address.Line2, &address.Line3, &address.Country, &address.State, &address.City, &address.Zip, &address.Phone, &address.Notes, &address.UserPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return address, nil

}

func (obj *sqlite3Impl) All_Address_By_UserPk(ctx context.Context,
	address_user_pk Address_UserPk_Field) (
	rows []*Address, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "addresses.user_pk", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT addresses.pk, addresses.id, addresses.created, addresses.line1, addresses.line2, addresses.line3, addresses.country, addresses.state, addresses.city, addresses.zip, addresses.phone, addresses.notes, addresses.user_pk FROM addresses WHERE "), __cond_0}}

	var __values []interface{}
	__values = append(__values)

	if !address_user_pk.isnull() {
		__cond_0.Null = false
		__values = append(__values, address_user_pk.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		address := &Address{}
		err = __rows.Scan(&address.Pk, &address.Id, &address.Created, &address.Line1, &address.Line2, &address.Line3, &address.Country, &address.State, &address.City, &address.Zip, &address.Phone, &address.Notes, &address.UserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, address)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_Address_By_User_Id(ctx context.Context,
	user_id User_Id_Field) (
	rows []*Address, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT addresses.pk, addresses.id, addresses.created, addresses.line1, addresses.line2, addresses.line3, addresses.country, addresses.state, addresses.city, addresses.zip, addresses.phone, addresses.notes, addresses.user_pk FROM addresses  JOIN users ON addresses.user_pk = users.pk WHERE users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		address := &Address{}
		err = __rows.Scan(&address.Pk, &address.Id, &address.Created, &address.Line1, &address.Line2, &address.Line3, &address.Country, &address.State, &address.City, &address.Zip, &address.Phone, &address.Notes, &address.UserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, address)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_Item(ctx context.Context) (
	rows []*Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items ORDER BY items.created DESC")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		item := &Item{}
		err = __rows.Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, item)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_Unavailable_Item(ctx context.Context) (
	rows []*Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items WHERE items.remaining_quantity = 0 ORDER BY items.created DESC")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		item := &Item{}
		err = __rows.Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, item)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_Available_Item(ctx context.Context) (
	rows []*Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items WHERE items.remaining_quantity > 0 ORDER BY items.created DESC")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		item := &Item{}
		err = __rows.Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, item)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_Item_By_Pk(ctx context.Context,
	item_pk Item_Pk_Field) (
	item *Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items WHERE items.pk = ?")

	var __values []interface{}
	__values = append(__values, item_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	item = &Item{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return item, nil

}

func (obj *sqlite3Impl) Find_Item_By_Id_And_RemainingQuantity_GreaterOrEqual(ctx context.Context,
	item_id Item_Id_Field,
	item_remaining_quantity_greater_or_equal Item_RemainingQuantity_Field) (
	item *Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items WHERE items.id = ? AND items.remaining_quantity >= ?")

	var __values []interface{}
	__values = append(__values, item_id.value(), item_remaining_quantity_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	item = &Item{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return item, nil

}

func (obj *sqlite3Impl) All_Item_By_RemainingQuantity_Greater_Number_And_Created_GreaterOrEqual(ctx context.Context,
	item_created_greater_or_equal Item_Created_Field) (
	rows []*Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items WHERE items.remaining_quantity > 0 AND items.created >= ?")

	var __values []interface{}
	__values = append(__values, item_created_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		item := &Item{}
		err = __rows.Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, item)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_Item_By_Item_RemainingQuantity_Greater_Number_And_User_Id(ctx context.Context,
	user_id User_Id_Field) (
	rows []*Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items  JOIN users ON items.owning_user_pk = users.pk WHERE items.remaining_quantity > 0 AND users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		item := &Item{}
		err = __rows.Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, item)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_CartItem_ItemId_By_SessionId(ctx context.Context,
	session_id Session_Id_Field) (
	rows []*CartItem_Item_Id_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT cart_items.pk, cart_items.id, cart_items.created, cart_items.quantity, cart_items.user_pk, cart_items.item_pk, items.id FROM cart_items  JOIN sessions ON cart_items.user_pk = sessions.user_pk  JOIN items ON cart_items.item_pk = items.pk WHERE sessions.id = ? ORDER BY cart_items.created DESC")

	var __values []interface{}
	__values = append(__values, session_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &CartItem_Item_Id_Row{}
		err = __rows.Scan(&row.CartItem.Pk, &row.CartItem.Id, &row.CartItem.Created, &row.CartItem.Quantity, &row.CartItem.UserPk, &row.CartItem.ItemPk, &row.Item_Id)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Find_CartItem_By_Item_Id_And_CartItem_UserPk(ctx context.Context,
	item_id Item_Id_Field,
	cart_item_user_pk CartItem_UserPk_Field) (
	cart_item *CartItem, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "cart_items.user_pk", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT cart_items.pk, cart_items.id, cart_items.created, cart_items.quantity, cart_items.user_pk, cart_items.item_pk FROM cart_items  JOIN items ON cart_items.item_pk = items.pk WHERE items.id = ? AND "), __cond_0, __sqlbundle_Literal(" LIMIT 2")}}

	var __values []interface{}
	__values = append(__values, item_id.value())

	if !cart_item_user_pk.isnull() {
		__cond_0.Null = false
		__values = append(__values, cart_item_user_pk.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	cart_item = &CartItem{}
	err = __rows.Scan(&cart_item.Pk, &cart_item.Id, &cart_item.Created, &cart_item.Quantity, &cart_item.UserPk, &cart_item.ItemPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("CartItem_By_Item_Id_And_CartItem_UserPk")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return cart_item, nil

}

func (obj *sqlite3Impl) Get_CartItem_By_Item_Id_And_CartItem_UserPk(ctx context.Context,
	item_id Item_Id_Field,
	cart_item_user_pk CartItem_UserPk_Field) (
	cart_item *CartItem, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "cart_items.user_pk", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT cart_items.pk, cart_items.id, cart_items.created, cart_items.quantity, cart_items.user_pk, cart_items.item_pk FROM cart_items  JOIN items ON cart_items.item_pk = items.pk WHERE items.id = ? AND "), __cond_0, __sqlbundle_Literal(" LIMIT 2")}}

	var __values []interface{}
	__values = append(__values, item_id.value())

	if !cart_item_user_pk.isnull() {
		__cond_0.Null = false
		__values = append(__values, cart_item_user_pk.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, makeErr(sql.ErrNoRows)
	}

	cart_item = &CartItem{}
	err = __rows.Scan(&cart_item.Pk, &cart_item.Id, &cart_item.Created, &cart_item.Quantity, &cart_item.UserPk, &cart_item.ItemPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("CartItem_By_Item_Id_And_CartItem_UserPk")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return cart_item, nil

}

func (obj *sqlite3Impl) All_OrderedItem_AddressId_ItemId_By_SessionId(ctx context.Context,
	session_id Session_Id_Field) (
	rows []*OrderedItem_Address_Id_Item_Id_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ordered_items.pk, ordered_items.id, ordered_items.created, ordered_items.quantity, ordered_items.delivered, ordered_items.price, ordered_items.user_pk, ordered_items.item_pk, ordered_items.address_pk, addresses.id, items.id FROM ordered_items  JOIN sessions ON ordered_items.user_pk = sessions.user_pk  JOIN addresses ON ordered_items.address_pk = addresses.pk  JOIN items ON ordered_items.item_pk = items.pk WHERE sessions.id = ? ORDER BY ordered_items.delivered, ordered_items.created DESC")

	var __values []interface{}
	__values = append(__values, session_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &OrderedItem_Address_Id_Item_Id_Row{}
		err = __rows.Scan(&row.OrderedItem.Pk, &row.OrderedItem.Id, &row.OrderedItem.Created, &row.OrderedItem.Quantity, &row.OrderedItem.Delivered, &row.OrderedItem.Price, &row.OrderedItem.UserPk, &row.OrderedItem.ItemPk, &row.OrderedItem.AddressPk, &row.Address_Id, &row.Item_Id)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) UpdateNoReturn_EmailPassword_By_Pk(ctx context.Context,
	email_password_pk EmailPassword_Pk_Field,
	update EmailPassword_Update_Fields) (
	err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE email_passwords SET "), __sets, __sqlbundle_Literal(" WHERE email_passwords.pk = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Email._set {
		__values = append(__values, update.Email.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("email = ?"))
	}

	if update.PasswordHash._set {
		__values = append(__values, update.PasswordHash.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("password_hash = ?"))
	}

	if update.PassowrdUpdated._set {
		__values = append(__values, update.PassowrdUpdated.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("passowrd_updated = ?"))
	}

	if update.Code._set {
		__values = append(__values, update.Code.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("code = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_login = ?"))

	__args = append(__args, email_password_pk.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *sqlite3Impl) Update_Item_By_Pk(ctx context.Context,
	item_pk Item_Pk_Field,
	update Item_Update_Fields) (
	item *Item, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE items SET "), __sets, __sqlbundle_Literal(" WHERE items.pk = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Price._set {
		__values = append(__values, update.Price.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("price = ?"))
	}

	if update.Description._set {
		__values = append(__values, update.Description.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("description = ?"))
	}

	if update.ImageUrl._set {
		__values = append(__values, update.ImageUrl.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("image_url = ?"))
	}

	if update.RemainingQuantity._set {
		__values = append(__values, update.RemainingQuantity.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("remaining_quantity = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, item_pk.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	item = &Item{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items WHERE items.pk = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return item, nil
}

func (obj *sqlite3Impl) UpdateNoReturn_Item_By_Pk(ctx context.Context,
	item_pk Item_Pk_Field,
	update Item_Update_Fields) (
	err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE items SET "), __sets, __sqlbundle_Literal(" WHERE items.pk = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Price._set {
		__values = append(__values, update.Price.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("price = ?"))
	}

	if update.Description._set {
		__values = append(__values, update.Description.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("description = ?"))
	}

	if update.ImageUrl._set {
		__values = append(__values, update.ImageUrl.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("image_url = ?"))
	}

	if update.RemainingQuantity._set {
		__values = append(__values, update.RemainingQuantity.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("remaining_quantity = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return emptyUpdate()
	}

	__args = append(__args, item_pk.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *sqlite3Impl) Update_Item_By_Id_And_OwningUserPk(ctx context.Context,
	item_id Item_Id_Field,
	item_owning_user_pk Item_OwningUserPk_Field,
	update Item_Update_Fields) (
	item *Item, err error) {
	var __sets = &__sqlbundle_Hole{}
	var __cond_0 = &__sqlbundle_Condition{Left: "items.owning_user_pk", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE items SET "), __sets, __sqlbundle_Literal(" WHERE items.id = ? AND "), __cond_0}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Price._set {
		__values = append(__values, update.Price.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("price = ?"))
	}

	if update.Description._set {
		__values = append(__values, update.Description.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("description = ?"))
	}

	if update.ImageUrl._set {
		__values = append(__values, update.ImageUrl.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("image_url = ?"))
	}

	if update.RemainingQuantity._set {
		__values = append(__values, update.RemainingQuantity.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("remaining_quantity = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, item_id.value())

	if !item_owning_user_pk.isnull() {
		__cond_0.Null = false
		__args = append(__args, item_owning_user_pk.value())
	}

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	item = &Item{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items WHERE items.id = ? AND "), __cond_0}}

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return item, nil
}

func (obj *sqlite3Impl) Update_CartItem_By_Pk(ctx context.Context,
	cart_item_pk CartItem_Pk_Field,
	update CartItem_Update_Fields) (
	cart_item *CartItem, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE cart_items SET "), __sets, __sqlbundle_Literal(" WHERE cart_items.pk = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Quantity._set {
		__values = append(__values, update.Quantity.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("quantity = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, cart_item_pk.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	cart_item = &CartItem{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT cart_items.pk, cart_items.id, cart_items.created, cart_items.quantity, cart_items.user_pk, cart_items.item_pk FROM cart_items WHERE cart_items.pk = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&cart_item.Pk, &cart_item.Id, &cart_item.Created, &cart_item.Quantity, &cart_item.UserPk, &cart_item.ItemPk)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return cart_item, nil
}

func (obj *sqlite3Impl) UpdateNoReturn_CartItem_By_Pk(ctx context.Context,
	cart_item_pk CartItem_Pk_Field,
	update CartItem_Update_Fields) (
	err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE cart_items SET "), __sets, __sqlbundle_Literal(" WHERE cart_items.pk = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Quantity._set {
		__values = append(__values, update.Quantity.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("quantity = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return emptyUpdate()
	}

	__args = append(__args, cart_item_pk.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *sqlite3Impl) Delete_Session_By_Pk(ctx context.Context,
	session_pk Session_Pk_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM sessions WHERE sessions.pk = ?")

	var __values []interface{}
	__values = append(__values, session_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_CartItem_By_Pk(ctx context.Context,
	cart_item_pk CartItem_Pk_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM cart_items WHERE cart_items.pk = ?")

	var __values []interface{}
	__values = append(__values, cart_item_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) getLastEmailPassword(ctx context.Context,
	pk int64) (
	email_password *EmailPassword, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT email_passwords.pk, email_passwords.email, email_passwords.password_hash, email_passwords.created, email_passwords.passowrd_updated, email_passwords.last_login, email_passwords.code FROM email_passwords WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	email_password = &EmailPassword{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&email_password.Pk, &email_password.Email, &email_password.PasswordHash, &email_password.Created, &email_password.PassowrdUpdated, &email_password.LastLogin, &email_password.Code)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return email_password, nil

}

func (obj *sqlite3Impl) getLastUser(ctx context.Context,
	pk int64) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.pk, users.id, users.email, users.created, users.profile_url, users.full_name FROM users WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&user.Pk, &user.Id, &user.Email, &user.Created, &user.ProfileUrl, &user.FullName)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *sqlite3Impl) getLastSession(ctx context.Context,
	pk int64) (
	session *Session, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT sessions.pk, sessions.id, sessions.created, sessions.id_token, sessions.access_token, sessions.refresh_token, sessions.access_token_expiry, sessions.device_name, sessions.user_pk FROM sessions WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	session = &Session{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&session.Pk, &session.Id, &session.Created, &session.IdToken, &session.AccessToken, &session.RefreshToken, &session.AccessTokenExpiry, &session.DeviceName, &session.UserPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return session, nil

}

func (obj *sqlite3Impl) getLastAddress(ctx context.Context,
	pk int64) (
	address *Address, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT addresses.pk, addresses.id, addresses.created, addresses.line1, addresses.line2, addresses.line3, addresses.country, addresses.state, addresses.city, addresses.zip, addresses.phone, addresses.notes, addresses.user_pk FROM addresses WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	address = &Address{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&address.Pk, &address.Id, &address.Created, &address.Line1, &address.Line2, &address.Line3, &address.Country, &address.State, &address.City, &address.Zip, &address.Phone, &address.Notes, &address.UserPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return address, nil

}

func (obj *sqlite3Impl) getLastItem(ctx context.Context,
	pk int64) (
	item *Item, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT items.pk, items.id, items.created, items.price, items.description, items.image_url, items.remaining_quantity, items.owning_user_pk FROM items WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	item = &Item{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&item.Pk, &item.Id, &item.Created, &item.Price, &item.Description, &item.ImageUrl, &item.RemainingQuantity, &item.OwningUserPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return item, nil

}

func (obj *sqlite3Impl) getLastCartItem(ctx context.Context,
	pk int64) (
	cart_item *CartItem, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT cart_items.pk, cart_items.id, cart_items.created, cart_items.quantity, cart_items.user_pk, cart_items.item_pk FROM cart_items WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	cart_item = &CartItem{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&cart_item.Pk, &cart_item.Id, &cart_item.Created, &cart_item.Quantity, &cart_item.UserPk, &cart_item.ItemPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return cart_item, nil

}

func (obj *sqlite3Impl) getLastOrderedItem(ctx context.Context,
	pk int64) (
	ordered_item *OrderedItem, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ordered_items.pk, ordered_items.id, ordered_items.created, ordered_items.quantity, ordered_items.delivered, ordered_items.price, ordered_items.user_pk, ordered_items.item_pk, ordered_items.address_pk FROM ordered_items WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	ordered_item = &OrderedItem{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&ordered_item.Pk, &ordered_item.Id, &ordered_item.Created, &ordered_item.Quantity, &ordered_item.Delivered, &ordered_item.Price, &ordered_item.UserPk, &ordered_item.ItemPk, &ordered_item.AddressPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return ordered_item, nil

}

func (impl sqlite3Impl) isConstraintError(err error) (
	constraint string, ok bool) {
	if e, ok := err.(sqlite3.Error); ok {
		if e.Code == sqlite3.ErrConstraint {
			msg := err.Error()
			colon := strings.LastIndex(msg, ":")
			if colon != -1 {
				return strings.TrimSpace(msg[colon:]), true
			}
			return "", true
		}
	}
	return "", false
}

func (obj *sqlite3Impl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.Exec("DELETE FROM ordered_items;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM cart_items;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM sessions;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM items;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM addresses;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM users;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM email_passwords;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

type Rx struct {
	db *DB
	tx *Tx
}

func (rx *Rx) UnsafeTx(ctx context.Context) (unsafe_tx *sql.Tx, err error) {
	tx, err := rx.getTx(ctx)
	if err != nil {
		return nil, err
	}
	return tx.Tx, nil
}

func (rx *Rx) getTx(ctx context.Context) (tx *Tx, err error) {
	if rx.tx == nil {
		if rx.tx, err = rx.db.Open(ctx); err != nil {
			return nil, err
		}
	}
	return rx.tx, nil
}

func (rx *Rx) Rebind(s string) string {
	return rx.db.Rebind(s)
}

func (rx *Rx) Commit() (err error) {
	if rx.tx != nil {
		err = rx.tx.Commit()
		rx.tx = nil
	}
	return err
}

func (rx *Rx) Rollback() (err error) {
	if rx.tx != nil {
		err = rx.tx.Rollback()
		rx.tx = nil
	}
	return err
}

func (rx *Rx) All_Address_By_UserPk(ctx context.Context,
	address_user_pk Address_UserPk_Field) (
	rows []*Address, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Address_By_UserPk(ctx, address_user_pk)
}

func (rx *Rx) All_Address_By_User_Id(ctx context.Context,
	user_id User_Id_Field) (
	rows []*Address, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Address_By_User_Id(ctx, user_id)
}

func (rx *Rx) All_Available_Item(ctx context.Context) (
	rows []*Item, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Available_Item(ctx)
}

func (rx *Rx) All_CartItem_ItemId_By_SessionId(ctx context.Context,
	session_id Session_Id_Field) (
	rows []*CartItem_Item_Id_Row, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_CartItem_ItemId_By_SessionId(ctx, session_id)
}

func (rx *Rx) All_Item(ctx context.Context) (
	rows []*Item, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Item(ctx)
}

func (rx *Rx) All_Item_By_Item_RemainingQuantity_Greater_Number_And_User_Id(ctx context.Context,
	user_id User_Id_Field) (
	rows []*Item, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Item_By_Item_RemainingQuantity_Greater_Number_And_User_Id(ctx, user_id)
}

func (rx *Rx) All_Item_By_RemainingQuantity_Greater_Number_And_Created_GreaterOrEqual(ctx context.Context,
	item_created_greater_or_equal Item_Created_Field) (
	rows []*Item, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Item_By_RemainingQuantity_Greater_Number_And_Created_GreaterOrEqual(ctx, item_created_greater_or_equal)
}

func (rx *Rx) All_OrderedItem_AddressId_ItemId_By_SessionId(ctx context.Context,
	session_id Session_Id_Field) (
	rows []*OrderedItem_Address_Id_Item_Id_Row, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_OrderedItem_AddressId_ItemId_By_SessionId(ctx, session_id)
}

func (rx *Rx) All_Session_By_User_Id_OrderBy_Desc_Session_Created(ctx context.Context,
	user_id User_Id_Field) (
	rows []*Session, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Session_By_User_Id_OrderBy_Desc_Session_Created(ctx, user_id)
}

func (rx *Rx) All_Unavailable_Item(ctx context.Context) (
	rows []*Item, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Unavailable_Item(ctx)
}

func (rx *Rx) CreateNoReturn_CartItem(ctx context.Context,
	cart_item_id CartItem_Id_Field,
	cart_item_quantity CartItem_Quantity_Field,
	optional CartItem_Create_Fields) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.CreateNoReturn_CartItem(ctx, cart_item_id, cart_item_quantity, optional)

}

func (rx *Rx) CreateNoReturn_EmailPassword(ctx context.Context,
	email_password_email EmailPassword_Email_Field,
	email_password_password_hash EmailPassword_PasswordHash_Field,
	email_password_code EmailPassword_Code_Field) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.CreateNoReturn_EmailPassword(ctx, email_password_email, email_password_password_hash, email_password_code)

}

func (rx *Rx) CreateNoReturn_OrderedItem(ctx context.Context,
	ordered_item_id OrderedItem_Id_Field,
	ordered_item_quantity OrderedItem_Quantity_Field,
	ordered_item_delivered OrderedItem_Delivered_Field,
	ordered_item_price OrderedItem_Price_Field,
	ordered_item_item_pk OrderedItem_ItemPk_Field,
	ordered_item_address_pk OrderedItem_AddressPk_Field,
	optional OrderedItem_Create_Fields) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.CreateNoReturn_OrderedItem(ctx, ordered_item_id, ordered_item_quantity, ordered_item_delivered, ordered_item_price, ordered_item_item_pk, ordered_item_address_pk, optional)

}

func (rx *Rx) Create_Address(ctx context.Context,
	address_id Address_Id_Field,
	address_line1 Address_Line1_Field,
	address_line2 Address_Line2_Field,
	address_line3 Address_Line3_Field,
	address_country Address_Country_Field,
	address_state Address_State_Field,
	address_city Address_City_Field,
	address_zip Address_Zip_Field,
	address_phone Address_Phone_Field,
	address_notes Address_Notes_Field,
	optional Address_Create_Fields) (
	address *Address, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Address(ctx, address_id, address_line1, address_line2, address_line3, address_country, address_state, address_city, address_zip, address_phone, address_notes, optional)

}

func (rx *Rx) Create_Item(ctx context.Context,
	item_id Item_Id_Field,
	item_price Item_Price_Field,
	item_description Item_Description_Field,
	item_image_url Item_ImageUrl_Field,
	item_remaining_quantity Item_RemainingQuantity_Field,
	optional Item_Create_Fields) (
	item *Item, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Item(ctx, item_id, item_price, item_description, item_image_url, item_remaining_quantity, optional)

}

func (rx *Rx) Create_Session(ctx context.Context,
	session_id Session_Id_Field,
	session_id_token Session_IdToken_Field,
	session_access_token Session_AccessToken_Field,
	session_refresh_token Session_RefreshToken_Field,
	session_access_token_expiry Session_AccessTokenExpiry_Field,
	session_device_name Session_DeviceName_Field,
	optional Session_Create_Fields) (
	session *Session, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Session(ctx, session_id, session_id_token, session_access_token, session_refresh_token, session_access_token_expiry, session_device_name, optional)

}

func (rx *Rx) Create_User(ctx context.Context,
	user_id User_Id_Field,
	user_email User_Email_Field,
	user_profile_url User_ProfileUrl_Field,
	user_full_name User_FullName_Field) (
	user *User, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_User(ctx, user_id, user_email, user_profile_url, user_full_name)

}

func (rx *Rx) Delete_CartItem_By_Pk(ctx context.Context,
	cart_item_pk CartItem_Pk_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_CartItem_By_Pk(ctx, cart_item_pk)
}

func (rx *Rx) Delete_Session_By_Pk(ctx context.Context,
	session_pk Session_Pk_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_Session_By_Pk(ctx, session_pk)
}

func (rx *Rx) Find_CartItem_By_Item_Id_And_CartItem_UserPk(ctx context.Context,
	item_id Item_Id_Field,
	cart_item_user_pk CartItem_UserPk_Field) (
	cart_item *CartItem, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_CartItem_By_Item_Id_And_CartItem_UserPk(ctx, item_id, cart_item_user_pk)
}

func (rx *Rx) Find_EmailPassword_By_Code_And_LastLogin_Greater(ctx context.Context,
	email_password_code EmailPassword_Code_Field,
	email_password_last_login_greater EmailPassword_LastLogin_Field) (
	email_password *EmailPassword, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_EmailPassword_By_Code_And_LastLogin_Greater(ctx, email_password_code, email_password_last_login_greater)
}

func (rx *Rx) Find_EmailPassword_By_Email_And_PasswordHash(ctx context.Context,
	email_password_email EmailPassword_Email_Field,
	email_password_password_hash EmailPassword_PasswordHash_Field) (
	email_password *EmailPassword, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_EmailPassword_By_Email_And_PasswordHash(ctx, email_password_email, email_password_password_hash)
}

func (rx *Rx) Find_Item_By_Id_And_RemainingQuantity_GreaterOrEqual(ctx context.Context,
	item_id Item_Id_Field,
	item_remaining_quantity_greater_or_equal Item_RemainingQuantity_Field) (
	item *Item, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_Item_By_Id_And_RemainingQuantity_GreaterOrEqual(ctx, item_id, item_remaining_quantity_greater_or_equal)
}

func (rx *Rx) Find_Session_By_AccessToken(ctx context.Context,
	session_access_token Session_AccessToken_Field) (
	session *Session, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_Session_By_AccessToken(ctx, session_access_token)
}

func (rx *Rx) Find_User_By_Email(ctx context.Context,
	user_email User_Email_Field) (
	user *User, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_User_By_Email(ctx, user_email)
}

func (rx *Rx) Find_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	user *User, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_User_By_Id(ctx, user_id)
}

func (rx *Rx) Find_User_By_Session_AccessToken(ctx context.Context,
	session_access_token Session_AccessToken_Field) (
	user *User, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_User_By_Session_AccessToken(ctx, session_access_token)
}

func (rx *Rx) Find_User_By_Session_Id(ctx context.Context,
	session_id Session_Id_Field) (
	user *User, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_User_By_Session_Id(ctx, session_id)
}

func (rx *Rx) Get_Address_By_Id(ctx context.Context,
	address_id Address_Id_Field) (
	address *Address, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_Address_By_Id(ctx, address_id)
}

func (rx *Rx) Get_CartItem_By_Item_Id_And_CartItem_UserPk(ctx context.Context,
	item_id Item_Id_Field,
	cart_item_user_pk CartItem_UserPk_Field) (
	cart_item *CartItem, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_CartItem_By_Item_Id_And_CartItem_UserPk(ctx, item_id, cart_item_user_pk)
}

func (rx *Rx) Get_Item_By_Pk(ctx context.Context,
	item_pk Item_Pk_Field) (
	item *Item, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_Item_By_Pk(ctx, item_pk)
}

func (rx *Rx) UpdateNoReturn_CartItem_By_Pk(ctx context.Context,
	cart_item_pk CartItem_Pk_Field,
	update CartItem_Update_Fields) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.UpdateNoReturn_CartItem_By_Pk(ctx, cart_item_pk, update)
}

func (rx *Rx) UpdateNoReturn_EmailPassword_By_Pk(ctx context.Context,
	email_password_pk EmailPassword_Pk_Field,
	update EmailPassword_Update_Fields) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.UpdateNoReturn_EmailPassword_By_Pk(ctx, email_password_pk, update)
}

func (rx *Rx) UpdateNoReturn_Item_By_Pk(ctx context.Context,
	item_pk Item_Pk_Field,
	update Item_Update_Fields) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.UpdateNoReturn_Item_By_Pk(ctx, item_pk, update)
}

func (rx *Rx) Update_CartItem_By_Pk(ctx context.Context,
	cart_item_pk CartItem_Pk_Field,
	update CartItem_Update_Fields) (
	cart_item *CartItem, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_CartItem_By_Pk(ctx, cart_item_pk, update)
}

func (rx *Rx) Update_Item_By_Id_And_OwningUserPk(ctx context.Context,
	item_id Item_Id_Field,
	item_owning_user_pk Item_OwningUserPk_Field,
	update Item_Update_Fields) (
	item *Item, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_Item_By_Id_And_OwningUserPk(ctx, item_id, item_owning_user_pk, update)
}

func (rx *Rx) Update_Item_By_Pk(ctx context.Context,
	item_pk Item_Pk_Field,
	update Item_Update_Fields) (
	item *Item, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_Item_By_Pk(ctx, item_pk, update)
}

type Methods interface {
	All_Address_By_UserPk(ctx context.Context,
		address_user_pk Address_UserPk_Field) (
		rows []*Address, err error)

	All_Address_By_User_Id(ctx context.Context,
		user_id User_Id_Field) (
		rows []*Address, err error)

	All_Available_Item(ctx context.Context) (
		rows []*Item, err error)

	All_CartItem_ItemId_By_SessionId(ctx context.Context,
		session_id Session_Id_Field) (
		rows []*CartItem_Item_Id_Row, err error)

	All_Item(ctx context.Context) (
		rows []*Item, err error)

	All_Item_By_Item_RemainingQuantity_Greater_Number_And_User_Id(ctx context.Context,
		user_id User_Id_Field) (
		rows []*Item, err error)

	All_Item_By_RemainingQuantity_Greater_Number_And_Created_GreaterOrEqual(ctx context.Context,
		item_created_greater_or_equal Item_Created_Field) (
		rows []*Item, err error)

	All_OrderedItem_AddressId_ItemId_By_SessionId(ctx context.Context,
		session_id Session_Id_Field) (
		rows []*OrderedItem_Address_Id_Item_Id_Row, err error)

	All_Session_By_User_Id_OrderBy_Desc_Session_Created(ctx context.Context,
		user_id User_Id_Field) (
		rows []*Session, err error)

	All_Unavailable_Item(ctx context.Context) (
		rows []*Item, err error)

	CreateNoReturn_CartItem(ctx context.Context,
		cart_item_id CartItem_Id_Field,
		cart_item_quantity CartItem_Quantity_Field,
		optional CartItem_Create_Fields) (
		err error)

	CreateNoReturn_EmailPassword(ctx context.Context,
		email_password_email EmailPassword_Email_Field,
		email_password_password_hash EmailPassword_PasswordHash_Field,
		email_password_code EmailPassword_Code_Field) (
		err error)

	CreateNoReturn_OrderedItem(ctx context.Context,
		ordered_item_id OrderedItem_Id_Field,
		ordered_item_quantity OrderedItem_Quantity_Field,
		ordered_item_delivered OrderedItem_Delivered_Field,
		ordered_item_price OrderedItem_Price_Field,
		ordered_item_item_pk OrderedItem_ItemPk_Field,
		ordered_item_address_pk OrderedItem_AddressPk_Field,
		optional OrderedItem_Create_Fields) (
		err error)

	Create_Address(ctx context.Context,
		address_id Address_Id_Field,
		address_line1 Address_Line1_Field,
		address_line2 Address_Line2_Field,
		address_line3 Address_Line3_Field,
		address_country Address_Country_Field,
		address_state Address_State_Field,
		address_city Address_City_Field,
		address_zip Address_Zip_Field,
		address_phone Address_Phone_Field,
		address_notes Address_Notes_Field,
		optional Address_Create_Fields) (
		address *Address, err error)

	Create_Item(ctx context.Context,
		item_id Item_Id_Field,
		item_price Item_Price_Field,
		item_description Item_Description_Field,
		item_image_url Item_ImageUrl_Field,
		item_remaining_quantity Item_RemainingQuantity_Field,
		optional Item_Create_Fields) (
		item *Item, err error)

	Create_Session(ctx context.Context,
		session_id Session_Id_Field,
		session_id_token Session_IdToken_Field,
		session_access_token Session_AccessToken_Field,
		session_refresh_token Session_RefreshToken_Field,
		session_access_token_expiry Session_AccessTokenExpiry_Field,
		session_device_name Session_DeviceName_Field,
		optional Session_Create_Fields) (
		session *Session, err error)

	Create_User(ctx context.Context,
		user_id User_Id_Field,
		user_email User_Email_Field,
		user_profile_url User_ProfileUrl_Field,
		user_full_name User_FullName_Field) (
		user *User, err error)

	Delete_CartItem_By_Pk(ctx context.Context,
		cart_item_pk CartItem_Pk_Field) (
		deleted bool, err error)

	Delete_Session_By_Pk(ctx context.Context,
		session_pk Session_Pk_Field) (
		deleted bool, err error)

	Find_CartItem_By_Item_Id_And_CartItem_UserPk(ctx context.Context,
		item_id Item_Id_Field,
		cart_item_user_pk CartItem_UserPk_Field) (
		cart_item *CartItem, err error)

	Find_EmailPassword_By_Code_And_LastLogin_Greater(ctx context.Context,
		email_password_code EmailPassword_Code_Field,
		email_password_last_login_greater EmailPassword_LastLogin_Field) (
		email_password *EmailPassword, err error)

	Find_EmailPassword_By_Email_And_PasswordHash(ctx context.Context,
		email_password_email EmailPassword_Email_Field,
		email_password_password_hash EmailPassword_PasswordHash_Field) (
		email_password *EmailPassword, err error)

	Find_Item_By_Id_And_RemainingQuantity_GreaterOrEqual(ctx context.Context,
		item_id Item_Id_Field,
		item_remaining_quantity_greater_or_equal Item_RemainingQuantity_Field) (
		item *Item, err error)

	Find_Session_By_AccessToken(ctx context.Context,
		session_access_token Session_AccessToken_Field) (
		session *Session, err error)

	Find_User_By_Email(ctx context.Context,
		user_email User_Email_Field) (
		user *User, err error)

	Find_User_By_Id(ctx context.Context,
		user_id User_Id_Field) (
		user *User, err error)

	Find_User_By_Session_AccessToken(ctx context.Context,
		session_access_token Session_AccessToken_Field) (
		user *User, err error)

	Find_User_By_Session_Id(ctx context.Context,
		session_id Session_Id_Field) (
		user *User, err error)

	Get_Address_By_Id(ctx context.Context,
		address_id Address_Id_Field) (
		address *Address, err error)

	Get_CartItem_By_Item_Id_And_CartItem_UserPk(ctx context.Context,
		item_id Item_Id_Field,
		cart_item_user_pk CartItem_UserPk_Field) (
		cart_item *CartItem, err error)

	Get_Item_By_Pk(ctx context.Context,
		item_pk Item_Pk_Field) (
		item *Item, err error)

	UpdateNoReturn_CartItem_By_Pk(ctx context.Context,
		cart_item_pk CartItem_Pk_Field,
		update CartItem_Update_Fields) (
		err error)

	UpdateNoReturn_EmailPassword_By_Pk(ctx context.Context,
		email_password_pk EmailPassword_Pk_Field,
		update EmailPassword_Update_Fields) (
		err error)

	UpdateNoReturn_Item_By_Pk(ctx context.Context,
		item_pk Item_Pk_Field,
		update Item_Update_Fields) (
		err error)

	Update_CartItem_By_Pk(ctx context.Context,
		cart_item_pk CartItem_Pk_Field,
		update CartItem_Update_Fields) (
		cart_item *CartItem, err error)

	Update_Item_By_Id_And_OwningUserPk(ctx context.Context,
		item_id Item_Id_Field,
		item_owning_user_pk Item_OwningUserPk_Field,
		update Item_Update_Fields) (
		item *Item, err error)

	Update_Item_By_Pk(ctx context.Context,
		item_pk Item_Pk_Field,
		update Item_Update_Fields) (
		item *Item, err error)
}

type TxMethods interface {
	Methods

	Rebind(s string) string
	Commit() error
	Rollback() error
}

type txMethods interface {
	TxMethods

	deleteAll(ctx context.Context) (int64, error)
	makeErr(err error) error
}

type DBMethods interface {
	Methods

	Schema() string
	Rebind(sql string) string
}

type dbMethods interface {
	DBMethods

	wrapTx(tx *sql.Tx) txMethods
	makeErr(err error) error
}

func openpostgres(source string) (*sql.DB, error) {
	return sql.Open("postgres", source)
}

var sqlite3DriverName = func() string {
	var id [16]byte
	rand.Read(id[:])
	return fmt.Sprintf("sqlite3_%x", string(id[:]))
}()

func init() {
	sql.Register(sqlite3DriverName, &sqlite3.SQLiteDriver{
		ConnectHook: sqlite3SetupConn,
	})
}

// SQLite3JournalMode controls the journal_mode pragma for all new connections.
// Since it is read without a mutex, it must be changed to the value you want
// before any Open calls.
var SQLite3JournalMode = "WAL"

func sqlite3SetupConn(conn *sqlite3.SQLiteConn) (err error) {
	_, err = conn.Exec("PRAGMA foreign_keys = ON", nil)
	if err != nil {
		return makeErr(err)
	}
	_, err = conn.Exec("PRAGMA journal_mode = "+SQLite3JournalMode, nil)
	if err != nil {
		return makeErr(err)
	}
	return nil
}

func opensqlite3(source string) (*sql.DB, error) {
	return sql.Open(sqlite3DriverName, source)
}
